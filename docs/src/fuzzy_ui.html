<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.fuzzy_ui API documentation</title>
<meta name="description" content="This module provides a `FuzzyUI` class for the FuzzyMatcher application, which is a tkinter user-interface â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.fuzzy_ui</code></h1>
</header>
<section id="section-intro">
<p>This module provides a <code><a title="src.fuzzy_ui.FuzzyUI" href="#src.fuzzy_ui.FuzzyUI">FuzzyUI</a></code> class for the FuzzyMatcher application, which is a tkinter user-interface.</p>
<p>Responsible for displaying information to the user and getting user-input to serve to the controller of the application.</p>
<p>Key functionalities:
- Fuzzy matching: Users can input strings and adjust the fuzziness threshold to find similar responses.
- Category management: Users can add, rename, or delete categories to organize matched responses effectively.
- Displaying data: Match results and categorized responses are displayed in Treeview widgets.
- File management: Users have options to start new projects, load existing projects, append data, save progress, and export results.</p>
<p>Main dependencies:
- <code>tkinter</code>: for the GUI components.
- <code>pandas</code>: for data manipulation.
- <code>inspect</code>: for cleaner error message displays.
- <code>ctypes</code>: for DPI awareness, ensuring the UI scales correctly on high-resolution displays.</p>
<p>Author: Louie Atkins-Turkish (louie@tapestryresearch.com)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides a `FuzzyUI` class for the FuzzyMatcher application, which is a tkinter user-interface.

Responsible for displaying information to the user and getting user-input to serve to the controller of the application.

Key functionalities:
    - Fuzzy matching: Users can input strings and adjust the fuzziness threshold to find similar responses.
    - Category management: Users can add, rename, or delete categories to organize matched responses effectively.
    - Displaying data: Match results and categorized responses are displayed in Treeview widgets.
    - File management: Users have options to start new projects, load existing projects, append data, save progress, and export results.

Main dependencies:
    - `tkinter`: for the GUI components.
    - `pandas`: for data manipulation.
    - `inspect`: for cleaner error message displays.
    - `ctypes`: for DPI awareness, ensuring the UI scales correctly on high-resolution displays.

Author: Louie Atkins-Turkish (louie@tapestryresearch.com)
&#34;&#34;&#34;

import logging
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from typing import Tuple
import inspect
import ctypes
import pandas as pd

logger = logging.getLogger(__name__)

# Set DPI awareness
ctypes.windll.shcore.SetProcessDpiAwareness(1)


class FuzzyUI(tk.Tk):
    &#34;&#34;&#34;
    A tkinter user interface class for fuzzy matching and categorizing survey responses.

    Attributes:
        - `WINDOW_SIZE_MULTIPLIER` (float): Defines the size of the main window relative to the screen size.
        - `is_including_missing_data` (tk.BooleanVar): A variable to track the inclusion of missing data when calculating category percentages for display.
        - `categorization_type` (tk.StringVar): A variable to track the type of categorization (Single or Multi)
            Single allows only one category per response, Multi allows multiple.

    Methods:
        - `display_fuzzy_match_results`: Displays the results of fuzzy matching in the corresponding Treeview.
        - `display_category_results`: Displays the categorized results in the corresponding Treeview.
        - `display_categories`: Displays the list of categories and related metrics in the corresponding Treeview.
        - `set_categorization_type_label`: Sets the label indicating the current categorization type.
        - `create_popup`: Creates a general purpose popup window.
        - `create_rename_category_popup`: Creates a popup window for renaming a category.
        - `create_ask_categorization_type_popup`: Creates a popup window for selecting the categorization type.
        - `show_open_file_dialog`: Displays a dialog to open a file.
        - `show_save_file_dialog`: Displays a dialog to save a file.
        - `show_askyesno`: Displays a Yes/No dialog.
        - `show_error`: Displays an error message dialog.
        - `show_info`: Displays an informational message dialog.
        - `show_warning`: Displays a warning message dialog.
        - `selected_match_responses`: Returns a set of selected responses from the match results Treeview.
        - `selected_category_responses`: Returns a set of selected responses from the category results Treeview.
        - `selected_categories`: Returns a set of selected categories from the categories Treeview.
        - `update_treeview_selections`: Updates the selections in Treeview widgets based on specified criteria.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up the main window, configures layout grids, creates frames and widgets, and binds window resize events.
        &#34;&#34;&#34;

        logger.info(&#34;Initializing UI&#34;)
        super().__init__()

        self.title(&#34;Fuzzy Matcher&#34;)
        self.WINDOW_SIZE_MULTIPLIER = 0.8
        self.update_coords(self.winfo_screenwidth(), self.winfo_screenheight())

        # UI variables
        self.is_including_missing_data = tk.BooleanVar(value=False)
        self.categorization_type = tk.StringVar(value=&#34;Single&#34;)

        # Setup the UI
        self.initialize_window()
        self.configure_grid()
        self.configure_frames()
        self.create_widgets()
        self.position_widgets_in_frames()
        self.configure_sub_grids()
        self.configure_style()
        self.resize_treeview_columns()
        self.resize_text_wraplength()

        # Bind resizing functions to window resize
        self.bind(&#34;&lt;Configure&gt;&#34;, self.on_window_resize)

    ### ----------------------- Setup ----------------------- ###
    def update_coords(self, screen_width: int, screen_height: int) -&gt; None:
        &#34;&#34;&#34;
        Updates the main window&#39;s position and size based on the screen dimensions.

        Args:
            screen_width (int): The width of the screen. Used with self.winfo_screenwidth().
            screen_height (int): The height of the screen. Used with self.winfo_screenheight().
        &#34;&#34;&#34;

        self.screen_width = screen_width
        self.screen_height = screen_height
        self.window_width = int(screen_width * self.WINDOW_SIZE_MULTIPLIER)
        self.window_height = int(screen_height * self.WINDOW_SIZE_MULTIPLIER)
        self.centre_x = int((screen_width - self.window_width) / 2)
        self.centre_y = int((screen_height - self.window_height) / 2)

    def initialize_window(self) -&gt; None:
        &#34;&#34;&#34;
        Initializes the main window with the same aspect ratio as your screen (augmented by `WINDOW_SIZE_MULTIPLIER`).
        Places it at the center of the screen.
        &#34;&#34;&#34;

        self.geometry(f&#34;{self.window_width}x{self.window_height}+{self.centre_x}+{self.centre_y}&#34;)
        # self.state(&#39;zoomed&#39;)

    def configure_grid(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the main window grid layout, defining how frames will be placed and resized.
        &#34;&#34;&#34;

        self.grid_columnconfigure(0, weight=1)  # Fuzzy matching
        self.grid_columnconfigure(1, weight=1)  # Category results
        self.grid_columnconfigure(2, weight=1)  # Categories display
        self.grid_rowconfigure(0, weight=0)  # Buttons, entries, labels, etc
        self.grid_rowconfigure(1, weight=1)  # Treeviews
        self.grid_rowconfigure(2, weight=0)  # Project management
        # Weights set such that all columns and only middle row can expand/contract

    def configure_frames(self) -&gt; None:
        &#34;&#34;&#34;
        Creates frames for different sections of the UI and positions them within the main window grid.
        `self.frames` is a dictionary of position names (e.g. &#34;top_left&#34;) to frames.
        &#34;&#34;&#34;

        self.frames = {}

        positions = [
            &#34;top_left&#34;,
            &#34;middle_left&#34;,
            &#34;bottom_left&#34;,
            &#34;top_middle&#34;,
            &#34;middle_middle&#34;,
            &#34;bottom_middle&#34;,
            &#34;top_right&#34;,
            &#34;middle_right&#34;,
            &#34;bottom_right&#34;,
        ]

        for position in positions:
            self.frames[position] = tk.Frame(self)

        self.frames[&#34;top_left&#34;].grid(row=0, column=0, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_left&#34;].grid(row=1, column=0, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_left&#34;].grid(row=2, column=0, sticky=&#34;new&#34;, padx=10, pady=10)
        self.frames[&#34;top_middle&#34;].grid(row=0, column=1, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_middle&#34;].grid(row=1, column=1, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_middle&#34;].grid(row=2, column=1, sticky=&#34;new&#34;, padx=10, pady=10)
        self.frames[&#34;top_right&#34;].grid(row=0, column=2, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_right&#34;].grid(row=1, column=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_right&#34;].grid(row=2, column=2, sticky=&#34;new&#34;, padx=10, pady=10)

    def create_widgets(self) -&gt; None:
        &#34;&#34;&#34;
        Creates various UI widgets (buttons, labels, entries, treeviews, etc.) and assigns them to frames.
        &#34;&#34;&#34;

        # Top left frame widgets (fuzzy matching entry, slider, buttons and lable)
        self.match_string_label = tk.Label(self.frames[&#34;top_left&#34;], text=&#34;Enter String to Match:&#34;)
        self.match_string_entry = tk.Entry(self.frames[&#34;top_left&#34;])
        self.threshold_label = tk.Label(
            self.frames[&#34;top_left&#34;],
            text=&#34;Set Fuzz Threshold (100 is precise, 0 is imprecise):&#34;,
        )
        self.threshold_slider = tk.Scale(
            self.frames[&#34;top_left&#34;], from_=0, to=100, orient=&#34;horizontal&#34;, resolution=1
        )
        self.threshold_slider.set(60)  # Setting default value to 60, gets decent results
        self.match_button = tk.Button(self.frames[&#34;top_left&#34;], text=&#34;Match&#34;)
        self.categorize_button = tk.Button(
            self.frames[&#34;top_left&#34;], text=&#34;Categorize Selected Results&#34;
        )
        self.categorization_label = tk.Label(
            self.frames[&#34;top_left&#34;], text=&#34;Categorization Type: Single&#34;
        )

        # Middle left frame widgets (fuzzy matching treeview)
        self.match_results_tree = ttk.Treeview(
            self.frames[&#34;middle_left&#34;],
            columns=(&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;),
            show=&#34;headings&#34;,
        )
        for col in [&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;]:
            self.match_results_tree.heading(col, text=col)
            if col != &#34;Response&#34;:
                self.match_results_tree.column(col, anchor=&#34;center&#34;)
        self.results_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_left&#34;],
            orient=&#34;vertical&#34;,
            command=self.match_results_tree.yview,
        )

        # Bottom left frame widgets (new project, load project, append data)
        self.new_project_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;New Project&#34;)
        self.load_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Load Project&#34;)
        self.append_data_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Append Data&#34;)

        # Top middle frame widgets (category results buttons and labels)
        self.display_category_results_for_selected_category_button = tk.Button(
            self.frames[&#34;top_middle&#34;], text=&#34;Display Category Results&#34;
        )
        self.recategorize_selected_responses_button = tk.Button(
            self.frames[&#34;top_middle&#34;], text=&#34;Recategorize Selected Results&#34;
        )
        self.category_results_label = tk.Label(
            self.frames[&#34;top_middle&#34;], text=&#34;Results for Category: &#34;
        )

        # Middle middle frame widgets (category results treeview)
        self.category_results_tree = ttk.Treeview(
            self.frames[&#34;middle_middle&#34;], columns=(&#34;Response&#34;, &#34;Count&#34;), show=&#34;headings&#34;
        )
        self.category_results_tree.heading(&#34;Response&#34;, text=&#34;Response&#34;)
        self.category_results_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
        self.category_results_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
        self.category_results_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_middle&#34;],
            orient=&#34;vertical&#34;,
            command=self.category_results_tree.yview,
        )

        # Bottom middle frame widgets (None)

        # Top right frame widgets (category buttons and entry)
        self.new_category_entry = tk.Entry(self.frames[&#34;top_right&#34;])
        self.add_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Add Category&#34;)
        self.rename_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Rename Category&#34;)
        self.delete_categories_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Delete Category&#34;)
        self.delete_categories_button.bind()
        self.include_missing_data_checkbox = tk.Checkbutton(
            self.frames[&#34;top_right&#34;],
            text=&#34;Base to total&#34;,
            variable=self.is_including_missing_data,
        )

        # Middle right frame widgets (categories treeview)
        self.categories_tree = ttk.Treeview(
            self.frames[&#34;middle_right&#34;],
            columns=(&#34;Category&#34;, &#34;Count&#34;, &#34;Percentage&#34;),
            show=&#34;headings&#34;,
        )
        self.categories_tree.heading(&#34;Category&#34;, text=&#34;Category&#34;)
        self.categories_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
        self.categories_tree.heading(&#34;Percentage&#34;, text=&#34;%&#34;)
        self.categories_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
        self.categories_tree.column(&#34;Percentage&#34;, anchor=&#34;center&#34;)
        self.categories_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_right&#34;],
            orient=&#34;vertical&#34;,
            command=self.categories_tree.yview,
        )

        # Bottom right frame widgets (new project, load project, save project, export to csv)
        self.export_csv_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Export to CSV&#34;)
        self.save_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Save Project&#34;)

    def position_widgets_in_frames(self) -&gt; None:
        &#34;&#34;&#34;
        Positions the created widgets within their respective frames, defining layout properties.
        &#34;&#34;&#34;

        # Top left frame widgets
        self.match_string_label.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
        self.match_string_entry.grid(row=1, column=0, sticky=&#34;ew&#34;, padx=5)
        self.threshold_label.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
        self.threshold_slider.grid(row=1, column=1, sticky=&#34;ew&#34;, padx=5)
        self.categorization_label.grid(row=2, column=1, sticky=&#34;ew&#34;)
        self.match_button.grid(row=3, column=0, sticky=&#34;ew&#34;, padx=10, pady=10)
        self.categorize_button.grid(row=3, column=1, sticky=&#34;ew&#34;, padx=10, pady=10)

        # Middle left frame widgets
        self.match_results_tree.grid(row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
        self.match_results_tree.configure(yscrollcommand=self.results_scrollbar.set)

        # Bottom left frame widgets
        self.new_project_button.grid(row=0, column=0, sticky=&#34;w&#34;, padx=10, pady=10)
        self.append_data_button.grid(row=0, column=1, sticky=&#34;w&#34;, padx=10, pady=10)
        self.load_button.grid(row=1, column=0, sticky=&#34;w&#34;, padx=10, pady=10)

        # Top middle frame widgets
        self.display_category_results_for_selected_category_button.grid(
            row=0, column=0, sticky=&#34;ew&#34;, padx=10, pady=10
        )
        self.recategorize_selected_responses_button.grid(
            row=0, column=1, sticky=&#34;ew&#34;, padx=10, pady=10
        )
        self.category_results_label.grid(
            row=1, column=0, columnspan=2, sticky=&#34;ew&#34;, padx=10, pady=10
        )

        # Middle middle frame widgets
        self.category_results_tree.grid(
            row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10
        )
        self.category_results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
        self.category_results_tree.configure(yscrollcommand=self.category_results_scrollbar.set)

        # Bottm middle frame widgets

        # Top right frame widgets
        self.new_category_entry.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
        self.add_category_button.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
        self.rename_category_button.grid(row=0, column=2, sticky=&#34;ew&#34;, padx=5)
        self.delete_categories_button.grid(row=0, column=3, sticky=&#34;ew&#34;, padx=5)
        self.include_missing_data_checkbox.grid(row=1, column=3, sticky=&#34;e&#34;)

        # Middle right frame widgets
        self.categories_tree.grid(row=0, column=0, columnspan=4, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.categories_scrollbar.grid(row=0, column=4, sticky=&#34;ns&#34;)
        self.categories_tree.configure(yscrollcommand=self.categories_scrollbar.set)

        # Bottom right frame widgets
        self.export_csv_button.grid(row=0, column=0, sticky=&#34;e&#34;, padx=10, pady=10)
        self.save_button.grid(row=1, column=0, sticky=&#34;e&#34;, padx=10, pady=10)

    def configure_sub_grids(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the grid layouts within individual frames, ensuring proper alignment and sizing of widgets.
        &#34;&#34;&#34;

        # Allow all buttons and treviews to expand/contract horizontally together
        for frame in self.frames.values():
            for col in range(frame.grid_size()[0]):
                frame.grid_columnconfigure(col, weight=1)

        for frame in [
            self.frames[&#34;middle_left&#34;],
            self.frames[&#34;middle_middle&#34;],
            self.frames[&#34;middle_right&#34;],
        ]:
            # Don&#39;t allow the scrollbars to expand horizontally
            last_column = frame.grid_size()[0] - 1
            frame.grid_columnconfigure(last_column, weight=0)
            # Allow the treeviews to expand vertically
            frame.grid_rowconfigure(0, weight=1)

        # Allow the bottom left frame buttons to group together on the left
        self.frames[&#34;bottom_left&#34;].grid_columnconfigure(0, weight=0)

    def configure_style(self) -&gt; None:
        &#34;&#34;&#34;
        Configure global properties of the interface, such as Treeview row height and text alignment.
        &#34;&#34;&#34;

        # Configure Treeview style for larger row height and centered column text
        style = ttk.Style(self)
        style.configure(&#34;Treeview&#34;, rowheight=25)
        style.configure(&#34;Treeview.Item&#34;, anchor=&#34;center&#34;)

    def on_window_resize(self, event) -&gt; None:
        &#34;&#34;&#34;
        Handles window resize events, resizing Treeview columns and text wrap lengths accordingly.

        Args:
            event: The resize event object.
        &#34;&#34;&#34;

        self.resize_treeview_columns()
        self.resize_text_wraplength()

    def resize_text_wraplength(self) -&gt; None:
        &#34;&#34;&#34;
        Adjusts the wrap length of text in labels, buttons, and radio buttons when the main window is resized.
        &#34;&#34;&#34;

        for frame in self.winfo_children():
            for widget in frame.winfo_children():
                if isinstance(widget, (tk.Label, tk.Button, tk.Radiobutton)):
                    # Extra added to make it slightly less eager to resize
                    width = widget.winfo_width() + 10
                    widget.configure(wraplength=width)

    def resize_treeview_columns(self) -&gt; None:
        &#34;&#34;&#34;
        Adjusts the width of Treeview columns based on the width of the Treeview widget during window resizing.

        Each column after the first one is set to 1/6th the total treeview width, and the first one takes the remaining space.
        &#34;&#34;&#34;

        for frame in self.winfo_children():
            for widget in frame.winfo_children():
                if isinstance(widget, ttk.Treeview):
                    treeview = widget
                    treeview_width = treeview.winfo_width()

                    num_columns = len(treeview[&#34;columns&#34;])
                    if num_columns &gt; 1:
                        # Each column after the first one is set to 1/6th the total treeview width
                        # The first one takes the remaining space.
                        secondary_column_width = treeview_width // 6
                        first_column_width = treeview_width - (
                            secondary_column_width * (num_columns - 1)
                        )

                        treeview.column(treeview[&#34;columns&#34;][0], width=first_column_width)
                        for col in treeview[&#34;columns&#34;][1:]:
                            treeview.column(col, minwidth=50, width=secondary_column_width)
                    else:
                        # If there is only one column, it should take all the space
                        treeview.column(treeview[&#34;columns&#34;][0], width=treeview_width)

    ### ----------------------- Display Management ----------------------- ###
    def display_fuzzy_match_results(self, processed_results: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Displays the results of fuzzy matching in the `match_results_tree` Treeview.

        Args:
            processed_results (pd.DataFrame): A DataFrame containing the fuzzy match results.
                Expected to contain &#39;response&#39;, &#39;score&#39;, and &#39;count&#39; columns.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying fuzzy match results&#34;)
        for item in self.match_results_tree.get_children():
            self.match_results_tree.delete(item)

        for _, row in processed_results.iterrows():
            self.match_results_tree.insert(
                &#34;&#34;, &#34;end&#34;, values=(row[&#34;response&#34;], row[&#34;score&#34;], row[&#34;count&#34;])
            )

    def display_category_results(
        self, category: str, responses_and_counts: list[Tuple[str, int]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Displays the results for a specific category in the `category_results_tree` Treeview.

        Args:
            category (str): The name of the category for which results are being displayed.
            responses_and_counts (list[Tuple[str, int]]): A list of tuples, each containing a response and the count of occurances.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying category results&#34;)
        for item in self.category_results_tree.get_children():
            self.category_results_tree.delete(item)

        for response, count in responses_and_counts:
            self.category_results_tree.insert(&#34;&#34;, &#34;end&#34;, values=(response, count))

        self.category_results_label.config(text=f&#34;Results for Category: {category}&#34;)

    def display_categories(self, formatted_categories_metrics: list[Tuple[str, int, str]]) -&gt; None:
        &#34;&#34;&#34;
        Displays the list of categories and related metrics in the `categories_tree` Treeview.

        Args:
            formatted_categories_metrics (list[Tuple[str, int, str]]): An list of tuples, each containing the category name,
                count of responses, and the percentage as a string.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying categories and metrics&#34;)
        selected_categories = self.selected_categories()

        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)

        for category, count, percentage_str in formatted_categories_metrics:
            self.categories_tree.insert(&#34;&#34;, &#34;end&#34;, values=(category, count, percentage_str))

        self.update_treeview_selections(selected_categories=selected_categories)

    def set_categorization_type_label(self) -&gt; None:
        &#34;&#34;&#34;
        Sets `categorization_type_label` to reflect the current value of the `categorization_type` variable.
        &#34;&#34;&#34;

        logger.info(&#34;Setting categorization type label&#34;)
        chosen_type = self.categorization_type.get()
        self.categorization_label.config(text=&#34;Categorization Type: &#34; + chosen_type)

    ### ----------------------- Popups ----------------------- ###
    def create_popup(self, title: str) -&gt; tk.Toplevel:
        &#34;&#34;&#34;
        Creates a general-purpose popup window.

        Args:
            title (str): The title of the popup window.

        Returns:
            tk.Toplevel: The created popup window.
        &#34;&#34;&#34;

        popup = tk.Toplevel(self)
        popup.title(title)

        # Center the popup on the main window
        self.POPUP_WIDTH = &#34;400&#34;
        self.POPUP_HEIGHT = &#34;200&#34;
        popup.geometry(f&#34;{self.POPUP_WIDTH}x{self.POPUP_HEIGHT}+{self.centre_x}+{self.centre_y}&#34;)

        # Keep the popup window on top
        # Ensure all events are directed to this window until closed
        # Set focus on this popup so that you can straight away press enter
        popup.transient(self)
        popup.grab_set()
        popup.focus_set()

        return popup

    def create_rename_category_popup(self, old_category: str) -&gt; None:
        &#34;&#34;&#34;
        Creates a popup window for renaming a category.

        Args:
            old_category (str): The name of the category to be renamed.
        &#34;&#34;&#34;

        logger.info(&#34;Creating rename category popup&#34;)
        self.rename_dialog_popup = self.create_popup(&#34;Rename Category&#34;)

        # Create widgets
        self.label = tk.Label(
            self.rename_dialog_popup, text=f&#34;Enter a new name for &#39;{old_category}&#39;:&#34;
        )
        self.rename_category_entry = tk.Entry(self.rename_dialog_popup)
        self.ok_button = tk.Button(self.rename_dialog_popup, text=&#34;OK&#34;)
        self.cancel_button = tk.Button(self.rename_dialog_popup, text=&#34;Cancel&#34;)

        # Add widgets to popup
        self.label.pack(pady=10)
        self.rename_category_entry.pack()
        self.ok_button.pack(side=&#34;left&#34;, padx=20)
        self.cancel_button.pack(side=&#34;right&#34;, padx=20)

        # Set focus to the string entry
        self.rename_category_entry.focus_set()

    def create_ask_categorization_type_popup(self):
        &#34;&#34;&#34;
        Creates a popup window that allows the user to select the categorization type (Single or Multi).
        &#34;&#34;&#34;

        logger.info(&#34;Creating categorization type popup&#34;)
        self.categorization_type_popup = self.create_popup(&#34;Select Categorization Type&#34;)

        # Create buttons that assign value to self.categoriztation_type
        single_categorization_rb = tk.Radiobutton(
            self.categorization_type_popup,
            text=&#34;Single Categorization&#34;,
            variable=self.categorization_type,
            value=&#34;Single&#34;,
        )
        multi_categorization_rb = tk.Radiobutton(
            self.categorization_type_popup,
            text=&#34;Multi Categorization&#34;,
            variable=self.categorization_type,
            value=&#34;Multi&#34;,
        )
        self.confirm_button = tk.Button(
            self.categorization_type_popup,
            text=&#34;Confirm&#34;,
        )

        # Functions to execute upon confirm/Enter
        def _on_confirm():
            self.set_categorization_type_label()
            self.categorization_type_popup.destroy()

        # Bind widgets to commands
        self.confirm_button.bind(&#34;&lt;Button-1&gt;&#34;, lambda event: _on_confirm())
        self.categorization_type_popup.bind(&#34;&lt;Return&gt;&#34;, lambda event: _on_confirm())

        # Add the buttons to the window
        single_categorization_rb.pack()
        multi_categorization_rb.pack()
        self.confirm_button.pack()

    ### ----------------------- Dialog Boxes ----------------------- ###
    def show_open_file_dialog(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Displays a dialog to open a file.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        Returns:
            str: The path of the selected file.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying open file dialog&#34;)
        return filedialog.askopenfilename(*args, **kwargs)

    def show_save_file_dialog(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Displays a dialog to save a file.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        Returns:
            str: The path where the file is to be saved.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying save file dialog&#34;)
        return filedialog.asksaveasfilename(*args, **kwargs)

    def show_askyesno(self, title: str, message: str) -&gt; bool:
        &#34;&#34;&#34;
        Displays a Yes/No dialog.

        Args:
            title (str): The title of the dialog.
            message (str): The message to be displayed in the dialog.

        Returns:
            bool: The answer of the user (True for &#39;Yes&#39;, False for &#39;No&#39;).
        &#34;&#34;&#34;

        logger.info(&#34;Displaying yes/no dialog&#34;)
        return messagebox.askyesno(title, message)

    def show_error(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays an error message dialog.

        Args:
            message (str): The error message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying error message&#34;)
        messagebox.showerror(&#34;Error&#34;, inspect.cleandoc(message))

    def show_info(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays an informational message dialog.

        Args:
            message (str): The informational message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying info message&#34;)
        messagebox.showinfo(&#34;Info&#34;, inspect.cleandoc(message))

    def show_warning(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays a warning message dialog.

        Args:
            message (str): The warning message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying warning message&#34;)
        messagebox.showwarning(&#34;Warning&#34;, inspect.cleandoc(message))

    ### ----------------------- Treeview Selections ----------------------- ###
    def selected_match_responses(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected responses from the `match_results_tree` Treeview.

        Returns:
            set[str]: The selected responses.
        &#34;&#34;&#34;

        return {
            self.match_results_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.match_results_tree.selection()
        }

    def selected_category_responses(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected responses from the `category_results_tree` Treeview.

        Returns:
            set[str]: The selected responses.
        &#34;&#34;&#34;

        return {
            self.category_results_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.category_results_tree.selection()
        }

    def selected_categories(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected categories from the `categories_tree` Treeview.

        Returns:
            set[str]: The selected categories.
        &#34;&#34;&#34;

        return {
            self.categories_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.categories_tree.selection()
        }

    def update_treeview_selections(
        self, selected_categories: set[str] = set(), selected_responses: set[str] = set()
    ) -&gt; None:
        &#34;&#34;&#34;
        Updates the selections in Treeview widgets based on specified criteria.

        Args:
            selected_categories (set[str], optional): A set of category names to be re-selected in the `categories_tree`.
            selected_responses (set[str], optional): A set of responses to be re-selected in the `match_results_tree`
                if categorization_type is &#39;Multi&#39;.
        &#34;&#34;&#34;

        def reselect_treeview_items(treeview, values):
            for item in treeview.get_children():
                if treeview.item(item)[&#34;values&#34;][0] in values:
                    treeview.selection_add(item)

        # Re-select categories and if multi-categorization re-select match results
        logger.info(&#34;Updating treeview selections&#34;)
        if selected_categories is not None:
            reselect_treeview_items(self.categories_tree, selected_categories)
        if self.categorization_type.get() == &#34;Multi&#34; and selected_responses is not None:
            reselect_treeview_items(self.match_results_tree, selected_responses)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.fuzzy_ui.FuzzyUI"><code class="flex name class">
<span>class <span class="ident">FuzzyUI</span></span>
</code></dt>
<dd>
<div class="desc"><p>A tkinter user interface class for fuzzy matching and categorizing survey responses.</p>
<h2 id="attributes">Attributes</h2>
<ul>
<li><code>WINDOW_SIZE_MULTIPLIER</code> (float): Defines the size of the main window relative to the screen size.</li>
<li><code>is_including_missing_data</code> (tk.BooleanVar): A variable to track the inclusion of missing data when calculating category percentages for display.</li>
<li><code>categorization_type</code> (tk.StringVar): A variable to track the type of categorization (Single or Multi)
Single allows only one category per response, Multi allows multiple.</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li><code>display_fuzzy_match_results</code>: Displays the results of fuzzy matching in the corresponding Treeview.</li>
<li><code>display_category_results</code>: Displays the categorized results in the corresponding Treeview.</li>
<li><code>display_categories</code>: Displays the list of categories and related metrics in the corresponding Treeview.</li>
<li><code>set_categorization_type_label</code>: Sets the label indicating the current categorization type.</li>
<li><code>create_popup</code>: Creates a general purpose popup window.</li>
<li><code>create_rename_category_popup</code>: Creates a popup window for renaming a category.</li>
<li><code>create_ask_categorization_type_popup</code>: Creates a popup window for selecting the categorization type.</li>
<li><code>show_open_file_dialog</code>: Displays a dialog to open a file.</li>
<li><code>show_save_file_dialog</code>: Displays a dialog to save a file.</li>
<li><code>show_askyesno</code>: Displays a Yes/No dialog.</li>
<li><code>show_error</code>: Displays an error message dialog.</li>
<li><code>show_info</code>: Displays an informational message dialog.</li>
<li><code>show_warning</code>: Displays a warning message dialog.</li>
<li><code>selected_match_responses</code>: Returns a set of selected responses from the match results Treeview.</li>
<li><code>selected_category_responses</code>: Returns a set of selected responses from the category results Treeview.</li>
<li><code>selected_categories</code>: Returns a set of selected categories from the categories Treeview.</li>
<li><code>update_treeview_selections</code>: Updates the selections in Treeview widgets based on specified criteria.</li>
</ul>
<p>Sets up the main window, configures layout grids, creates frames and widgets, and binds window resize events.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuzzyUI(tk.Tk):
    &#34;&#34;&#34;
    A tkinter user interface class for fuzzy matching and categorizing survey responses.

    Attributes:
        - `WINDOW_SIZE_MULTIPLIER` (float): Defines the size of the main window relative to the screen size.
        - `is_including_missing_data` (tk.BooleanVar): A variable to track the inclusion of missing data when calculating category percentages for display.
        - `categorization_type` (tk.StringVar): A variable to track the type of categorization (Single or Multi)
            Single allows only one category per response, Multi allows multiple.

    Methods:
        - `display_fuzzy_match_results`: Displays the results of fuzzy matching in the corresponding Treeview.
        - `display_category_results`: Displays the categorized results in the corresponding Treeview.
        - `display_categories`: Displays the list of categories and related metrics in the corresponding Treeview.
        - `set_categorization_type_label`: Sets the label indicating the current categorization type.
        - `create_popup`: Creates a general purpose popup window.
        - `create_rename_category_popup`: Creates a popup window for renaming a category.
        - `create_ask_categorization_type_popup`: Creates a popup window for selecting the categorization type.
        - `show_open_file_dialog`: Displays a dialog to open a file.
        - `show_save_file_dialog`: Displays a dialog to save a file.
        - `show_askyesno`: Displays a Yes/No dialog.
        - `show_error`: Displays an error message dialog.
        - `show_info`: Displays an informational message dialog.
        - `show_warning`: Displays a warning message dialog.
        - `selected_match_responses`: Returns a set of selected responses from the match results Treeview.
        - `selected_category_responses`: Returns a set of selected responses from the category results Treeview.
        - `selected_categories`: Returns a set of selected categories from the categories Treeview.
        - `update_treeview_selections`: Updates the selections in Treeview widgets based on specified criteria.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        Sets up the main window, configures layout grids, creates frames and widgets, and binds window resize events.
        &#34;&#34;&#34;

        logger.info(&#34;Initializing UI&#34;)
        super().__init__()

        self.title(&#34;Fuzzy Matcher&#34;)
        self.WINDOW_SIZE_MULTIPLIER = 0.8
        self.update_coords(self.winfo_screenwidth(), self.winfo_screenheight())

        # UI variables
        self.is_including_missing_data = tk.BooleanVar(value=False)
        self.categorization_type = tk.StringVar(value=&#34;Single&#34;)

        # Setup the UI
        self.initialize_window()
        self.configure_grid()
        self.configure_frames()
        self.create_widgets()
        self.position_widgets_in_frames()
        self.configure_sub_grids()
        self.configure_style()
        self.resize_treeview_columns()
        self.resize_text_wraplength()

        # Bind resizing functions to window resize
        self.bind(&#34;&lt;Configure&gt;&#34;, self.on_window_resize)

    ### ----------------------- Setup ----------------------- ###
    def update_coords(self, screen_width: int, screen_height: int) -&gt; None:
        &#34;&#34;&#34;
        Updates the main window&#39;s position and size based on the screen dimensions.

        Args:
            screen_width (int): The width of the screen. Used with self.winfo_screenwidth().
            screen_height (int): The height of the screen. Used with self.winfo_screenheight().
        &#34;&#34;&#34;

        self.screen_width = screen_width
        self.screen_height = screen_height
        self.window_width = int(screen_width * self.WINDOW_SIZE_MULTIPLIER)
        self.window_height = int(screen_height * self.WINDOW_SIZE_MULTIPLIER)
        self.centre_x = int((screen_width - self.window_width) / 2)
        self.centre_y = int((screen_height - self.window_height) / 2)

    def initialize_window(self) -&gt; None:
        &#34;&#34;&#34;
        Initializes the main window with the same aspect ratio as your screen (augmented by `WINDOW_SIZE_MULTIPLIER`).
        Places it at the center of the screen.
        &#34;&#34;&#34;

        self.geometry(f&#34;{self.window_width}x{self.window_height}+{self.centre_x}+{self.centre_y}&#34;)
        # self.state(&#39;zoomed&#39;)

    def configure_grid(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the main window grid layout, defining how frames will be placed and resized.
        &#34;&#34;&#34;

        self.grid_columnconfigure(0, weight=1)  # Fuzzy matching
        self.grid_columnconfigure(1, weight=1)  # Category results
        self.grid_columnconfigure(2, weight=1)  # Categories display
        self.grid_rowconfigure(0, weight=0)  # Buttons, entries, labels, etc
        self.grid_rowconfigure(1, weight=1)  # Treeviews
        self.grid_rowconfigure(2, weight=0)  # Project management
        # Weights set such that all columns and only middle row can expand/contract

    def configure_frames(self) -&gt; None:
        &#34;&#34;&#34;
        Creates frames for different sections of the UI and positions them within the main window grid.
        `self.frames` is a dictionary of position names (e.g. &#34;top_left&#34;) to frames.
        &#34;&#34;&#34;

        self.frames = {}

        positions = [
            &#34;top_left&#34;,
            &#34;middle_left&#34;,
            &#34;bottom_left&#34;,
            &#34;top_middle&#34;,
            &#34;middle_middle&#34;,
            &#34;bottom_middle&#34;,
            &#34;top_right&#34;,
            &#34;middle_right&#34;,
            &#34;bottom_right&#34;,
        ]

        for position in positions:
            self.frames[position] = tk.Frame(self)

        self.frames[&#34;top_left&#34;].grid(row=0, column=0, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_left&#34;].grid(row=1, column=0, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_left&#34;].grid(row=2, column=0, sticky=&#34;new&#34;, padx=10, pady=10)
        self.frames[&#34;top_middle&#34;].grid(row=0, column=1, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_middle&#34;].grid(row=1, column=1, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_middle&#34;].grid(row=2, column=1, sticky=&#34;new&#34;, padx=10, pady=10)
        self.frames[&#34;top_right&#34;].grid(row=0, column=2, sticky=&#34;sew&#34;, padx=10, pady=10)
        self.frames[&#34;middle_right&#34;].grid(row=1, column=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.frames[&#34;bottom_right&#34;].grid(row=2, column=2, sticky=&#34;new&#34;, padx=10, pady=10)

    def create_widgets(self) -&gt; None:
        &#34;&#34;&#34;
        Creates various UI widgets (buttons, labels, entries, treeviews, etc.) and assigns them to frames.
        &#34;&#34;&#34;

        # Top left frame widgets (fuzzy matching entry, slider, buttons and lable)
        self.match_string_label = tk.Label(self.frames[&#34;top_left&#34;], text=&#34;Enter String to Match:&#34;)
        self.match_string_entry = tk.Entry(self.frames[&#34;top_left&#34;])
        self.threshold_label = tk.Label(
            self.frames[&#34;top_left&#34;],
            text=&#34;Set Fuzz Threshold (100 is precise, 0 is imprecise):&#34;,
        )
        self.threshold_slider = tk.Scale(
            self.frames[&#34;top_left&#34;], from_=0, to=100, orient=&#34;horizontal&#34;, resolution=1
        )
        self.threshold_slider.set(60)  # Setting default value to 60, gets decent results
        self.match_button = tk.Button(self.frames[&#34;top_left&#34;], text=&#34;Match&#34;)
        self.categorize_button = tk.Button(
            self.frames[&#34;top_left&#34;], text=&#34;Categorize Selected Results&#34;
        )
        self.categorization_label = tk.Label(
            self.frames[&#34;top_left&#34;], text=&#34;Categorization Type: Single&#34;
        )

        # Middle left frame widgets (fuzzy matching treeview)
        self.match_results_tree = ttk.Treeview(
            self.frames[&#34;middle_left&#34;],
            columns=(&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;),
            show=&#34;headings&#34;,
        )
        for col in [&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;]:
            self.match_results_tree.heading(col, text=col)
            if col != &#34;Response&#34;:
                self.match_results_tree.column(col, anchor=&#34;center&#34;)
        self.results_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_left&#34;],
            orient=&#34;vertical&#34;,
            command=self.match_results_tree.yview,
        )

        # Bottom left frame widgets (new project, load project, append data)
        self.new_project_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;New Project&#34;)
        self.load_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Load Project&#34;)
        self.append_data_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Append Data&#34;)

        # Top middle frame widgets (category results buttons and labels)
        self.display_category_results_for_selected_category_button = tk.Button(
            self.frames[&#34;top_middle&#34;], text=&#34;Display Category Results&#34;
        )
        self.recategorize_selected_responses_button = tk.Button(
            self.frames[&#34;top_middle&#34;], text=&#34;Recategorize Selected Results&#34;
        )
        self.category_results_label = tk.Label(
            self.frames[&#34;top_middle&#34;], text=&#34;Results for Category: &#34;
        )

        # Middle middle frame widgets (category results treeview)
        self.category_results_tree = ttk.Treeview(
            self.frames[&#34;middle_middle&#34;], columns=(&#34;Response&#34;, &#34;Count&#34;), show=&#34;headings&#34;
        )
        self.category_results_tree.heading(&#34;Response&#34;, text=&#34;Response&#34;)
        self.category_results_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
        self.category_results_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
        self.category_results_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_middle&#34;],
            orient=&#34;vertical&#34;,
            command=self.category_results_tree.yview,
        )

        # Bottom middle frame widgets (None)

        # Top right frame widgets (category buttons and entry)
        self.new_category_entry = tk.Entry(self.frames[&#34;top_right&#34;])
        self.add_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Add Category&#34;)
        self.rename_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Rename Category&#34;)
        self.delete_categories_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Delete Category&#34;)
        self.delete_categories_button.bind()
        self.include_missing_data_checkbox = tk.Checkbutton(
            self.frames[&#34;top_right&#34;],
            text=&#34;Base to total&#34;,
            variable=self.is_including_missing_data,
        )

        # Middle right frame widgets (categories treeview)
        self.categories_tree = ttk.Treeview(
            self.frames[&#34;middle_right&#34;],
            columns=(&#34;Category&#34;, &#34;Count&#34;, &#34;Percentage&#34;),
            show=&#34;headings&#34;,
        )
        self.categories_tree.heading(&#34;Category&#34;, text=&#34;Category&#34;)
        self.categories_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
        self.categories_tree.heading(&#34;Percentage&#34;, text=&#34;%&#34;)
        self.categories_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
        self.categories_tree.column(&#34;Percentage&#34;, anchor=&#34;center&#34;)
        self.categories_scrollbar = tk.Scrollbar(
            self.frames[&#34;middle_right&#34;],
            orient=&#34;vertical&#34;,
            command=self.categories_tree.yview,
        )

        # Bottom right frame widgets (new project, load project, save project, export to csv)
        self.export_csv_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Export to CSV&#34;)
        self.save_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Save Project&#34;)

    def position_widgets_in_frames(self) -&gt; None:
        &#34;&#34;&#34;
        Positions the created widgets within their respective frames, defining layout properties.
        &#34;&#34;&#34;

        # Top left frame widgets
        self.match_string_label.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
        self.match_string_entry.grid(row=1, column=0, sticky=&#34;ew&#34;, padx=5)
        self.threshold_label.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
        self.threshold_slider.grid(row=1, column=1, sticky=&#34;ew&#34;, padx=5)
        self.categorization_label.grid(row=2, column=1, sticky=&#34;ew&#34;)
        self.match_button.grid(row=3, column=0, sticky=&#34;ew&#34;, padx=10, pady=10)
        self.categorize_button.grid(row=3, column=1, sticky=&#34;ew&#34;, padx=10, pady=10)

        # Middle left frame widgets
        self.match_results_tree.grid(row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
        self.match_results_tree.configure(yscrollcommand=self.results_scrollbar.set)

        # Bottom left frame widgets
        self.new_project_button.grid(row=0, column=0, sticky=&#34;w&#34;, padx=10, pady=10)
        self.append_data_button.grid(row=0, column=1, sticky=&#34;w&#34;, padx=10, pady=10)
        self.load_button.grid(row=1, column=0, sticky=&#34;w&#34;, padx=10, pady=10)

        # Top middle frame widgets
        self.display_category_results_for_selected_category_button.grid(
            row=0, column=0, sticky=&#34;ew&#34;, padx=10, pady=10
        )
        self.recategorize_selected_responses_button.grid(
            row=0, column=1, sticky=&#34;ew&#34;, padx=10, pady=10
        )
        self.category_results_label.grid(
            row=1, column=0, columnspan=2, sticky=&#34;ew&#34;, padx=10, pady=10
        )

        # Middle middle frame widgets
        self.category_results_tree.grid(
            row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10
        )
        self.category_results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
        self.category_results_tree.configure(yscrollcommand=self.category_results_scrollbar.set)

        # Bottm middle frame widgets

        # Top right frame widgets
        self.new_category_entry.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
        self.add_category_button.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
        self.rename_category_button.grid(row=0, column=2, sticky=&#34;ew&#34;, padx=5)
        self.delete_categories_button.grid(row=0, column=3, sticky=&#34;ew&#34;, padx=5)
        self.include_missing_data_checkbox.grid(row=1, column=3, sticky=&#34;e&#34;)

        # Middle right frame widgets
        self.categories_tree.grid(row=0, column=0, columnspan=4, sticky=&#34;nsew&#34;, padx=10, pady=10)
        self.categories_scrollbar.grid(row=0, column=4, sticky=&#34;ns&#34;)
        self.categories_tree.configure(yscrollcommand=self.categories_scrollbar.set)

        # Bottom right frame widgets
        self.export_csv_button.grid(row=0, column=0, sticky=&#34;e&#34;, padx=10, pady=10)
        self.save_button.grid(row=1, column=0, sticky=&#34;e&#34;, padx=10, pady=10)

    def configure_sub_grids(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the grid layouts within individual frames, ensuring proper alignment and sizing of widgets.
        &#34;&#34;&#34;

        # Allow all buttons and treviews to expand/contract horizontally together
        for frame in self.frames.values():
            for col in range(frame.grid_size()[0]):
                frame.grid_columnconfigure(col, weight=1)

        for frame in [
            self.frames[&#34;middle_left&#34;],
            self.frames[&#34;middle_middle&#34;],
            self.frames[&#34;middle_right&#34;],
        ]:
            # Don&#39;t allow the scrollbars to expand horizontally
            last_column = frame.grid_size()[0] - 1
            frame.grid_columnconfigure(last_column, weight=0)
            # Allow the treeviews to expand vertically
            frame.grid_rowconfigure(0, weight=1)

        # Allow the bottom left frame buttons to group together on the left
        self.frames[&#34;bottom_left&#34;].grid_columnconfigure(0, weight=0)

    def configure_style(self) -&gt; None:
        &#34;&#34;&#34;
        Configure global properties of the interface, such as Treeview row height and text alignment.
        &#34;&#34;&#34;

        # Configure Treeview style for larger row height and centered column text
        style = ttk.Style(self)
        style.configure(&#34;Treeview&#34;, rowheight=25)
        style.configure(&#34;Treeview.Item&#34;, anchor=&#34;center&#34;)

    def on_window_resize(self, event) -&gt; None:
        &#34;&#34;&#34;
        Handles window resize events, resizing Treeview columns and text wrap lengths accordingly.

        Args:
            event: The resize event object.
        &#34;&#34;&#34;

        self.resize_treeview_columns()
        self.resize_text_wraplength()

    def resize_text_wraplength(self) -&gt; None:
        &#34;&#34;&#34;
        Adjusts the wrap length of text in labels, buttons, and radio buttons when the main window is resized.
        &#34;&#34;&#34;

        for frame in self.winfo_children():
            for widget in frame.winfo_children():
                if isinstance(widget, (tk.Label, tk.Button, tk.Radiobutton)):
                    # Extra added to make it slightly less eager to resize
                    width = widget.winfo_width() + 10
                    widget.configure(wraplength=width)

    def resize_treeview_columns(self) -&gt; None:
        &#34;&#34;&#34;
        Adjusts the width of Treeview columns based on the width of the Treeview widget during window resizing.

        Each column after the first one is set to 1/6th the total treeview width, and the first one takes the remaining space.
        &#34;&#34;&#34;

        for frame in self.winfo_children():
            for widget in frame.winfo_children():
                if isinstance(widget, ttk.Treeview):
                    treeview = widget
                    treeview_width = treeview.winfo_width()

                    num_columns = len(treeview[&#34;columns&#34;])
                    if num_columns &gt; 1:
                        # Each column after the first one is set to 1/6th the total treeview width
                        # The first one takes the remaining space.
                        secondary_column_width = treeview_width // 6
                        first_column_width = treeview_width - (
                            secondary_column_width * (num_columns - 1)
                        )

                        treeview.column(treeview[&#34;columns&#34;][0], width=first_column_width)
                        for col in treeview[&#34;columns&#34;][1:]:
                            treeview.column(col, minwidth=50, width=secondary_column_width)
                    else:
                        # If there is only one column, it should take all the space
                        treeview.column(treeview[&#34;columns&#34;][0], width=treeview_width)

    ### ----------------------- Display Management ----------------------- ###
    def display_fuzzy_match_results(self, processed_results: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Displays the results of fuzzy matching in the `match_results_tree` Treeview.

        Args:
            processed_results (pd.DataFrame): A DataFrame containing the fuzzy match results.
                Expected to contain &#39;response&#39;, &#39;score&#39;, and &#39;count&#39; columns.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying fuzzy match results&#34;)
        for item in self.match_results_tree.get_children():
            self.match_results_tree.delete(item)

        for _, row in processed_results.iterrows():
            self.match_results_tree.insert(
                &#34;&#34;, &#34;end&#34;, values=(row[&#34;response&#34;], row[&#34;score&#34;], row[&#34;count&#34;])
            )

    def display_category_results(
        self, category: str, responses_and_counts: list[Tuple[str, int]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Displays the results for a specific category in the `category_results_tree` Treeview.

        Args:
            category (str): The name of the category for which results are being displayed.
            responses_and_counts (list[Tuple[str, int]]): A list of tuples, each containing a response and the count of occurances.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying category results&#34;)
        for item in self.category_results_tree.get_children():
            self.category_results_tree.delete(item)

        for response, count in responses_and_counts:
            self.category_results_tree.insert(&#34;&#34;, &#34;end&#34;, values=(response, count))

        self.category_results_label.config(text=f&#34;Results for Category: {category}&#34;)

    def display_categories(self, formatted_categories_metrics: list[Tuple[str, int, str]]) -&gt; None:
        &#34;&#34;&#34;
        Displays the list of categories and related metrics in the `categories_tree` Treeview.

        Args:
            formatted_categories_metrics (list[Tuple[str, int, str]]): An list of tuples, each containing the category name,
                count of responses, and the percentage as a string.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying categories and metrics&#34;)
        selected_categories = self.selected_categories()

        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)

        for category, count, percentage_str in formatted_categories_metrics:
            self.categories_tree.insert(&#34;&#34;, &#34;end&#34;, values=(category, count, percentage_str))

        self.update_treeview_selections(selected_categories=selected_categories)

    def set_categorization_type_label(self) -&gt; None:
        &#34;&#34;&#34;
        Sets `categorization_type_label` to reflect the current value of the `categorization_type` variable.
        &#34;&#34;&#34;

        logger.info(&#34;Setting categorization type label&#34;)
        chosen_type = self.categorization_type.get()
        self.categorization_label.config(text=&#34;Categorization Type: &#34; + chosen_type)

    ### ----------------------- Popups ----------------------- ###
    def create_popup(self, title: str) -&gt; tk.Toplevel:
        &#34;&#34;&#34;
        Creates a general-purpose popup window.

        Args:
            title (str): The title of the popup window.

        Returns:
            tk.Toplevel: The created popup window.
        &#34;&#34;&#34;

        popup = tk.Toplevel(self)
        popup.title(title)

        # Center the popup on the main window
        self.POPUP_WIDTH = &#34;400&#34;
        self.POPUP_HEIGHT = &#34;200&#34;
        popup.geometry(f&#34;{self.POPUP_WIDTH}x{self.POPUP_HEIGHT}+{self.centre_x}+{self.centre_y}&#34;)

        # Keep the popup window on top
        # Ensure all events are directed to this window until closed
        # Set focus on this popup so that you can straight away press enter
        popup.transient(self)
        popup.grab_set()
        popup.focus_set()

        return popup

    def create_rename_category_popup(self, old_category: str) -&gt; None:
        &#34;&#34;&#34;
        Creates a popup window for renaming a category.

        Args:
            old_category (str): The name of the category to be renamed.
        &#34;&#34;&#34;

        logger.info(&#34;Creating rename category popup&#34;)
        self.rename_dialog_popup = self.create_popup(&#34;Rename Category&#34;)

        # Create widgets
        self.label = tk.Label(
            self.rename_dialog_popup, text=f&#34;Enter a new name for &#39;{old_category}&#39;:&#34;
        )
        self.rename_category_entry = tk.Entry(self.rename_dialog_popup)
        self.ok_button = tk.Button(self.rename_dialog_popup, text=&#34;OK&#34;)
        self.cancel_button = tk.Button(self.rename_dialog_popup, text=&#34;Cancel&#34;)

        # Add widgets to popup
        self.label.pack(pady=10)
        self.rename_category_entry.pack()
        self.ok_button.pack(side=&#34;left&#34;, padx=20)
        self.cancel_button.pack(side=&#34;right&#34;, padx=20)

        # Set focus to the string entry
        self.rename_category_entry.focus_set()

    def create_ask_categorization_type_popup(self):
        &#34;&#34;&#34;
        Creates a popup window that allows the user to select the categorization type (Single or Multi).
        &#34;&#34;&#34;

        logger.info(&#34;Creating categorization type popup&#34;)
        self.categorization_type_popup = self.create_popup(&#34;Select Categorization Type&#34;)

        # Create buttons that assign value to self.categoriztation_type
        single_categorization_rb = tk.Radiobutton(
            self.categorization_type_popup,
            text=&#34;Single Categorization&#34;,
            variable=self.categorization_type,
            value=&#34;Single&#34;,
        )
        multi_categorization_rb = tk.Radiobutton(
            self.categorization_type_popup,
            text=&#34;Multi Categorization&#34;,
            variable=self.categorization_type,
            value=&#34;Multi&#34;,
        )
        self.confirm_button = tk.Button(
            self.categorization_type_popup,
            text=&#34;Confirm&#34;,
        )

        # Functions to execute upon confirm/Enter
        def _on_confirm():
            self.set_categorization_type_label()
            self.categorization_type_popup.destroy()

        # Bind widgets to commands
        self.confirm_button.bind(&#34;&lt;Button-1&gt;&#34;, lambda event: _on_confirm())
        self.categorization_type_popup.bind(&#34;&lt;Return&gt;&#34;, lambda event: _on_confirm())

        # Add the buttons to the window
        single_categorization_rb.pack()
        multi_categorization_rb.pack()
        self.confirm_button.pack()

    ### ----------------------- Dialog Boxes ----------------------- ###
    def show_open_file_dialog(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Displays a dialog to open a file.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        Returns:
            str: The path of the selected file.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying open file dialog&#34;)
        return filedialog.askopenfilename(*args, **kwargs)

    def show_save_file_dialog(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34;
        Displays a dialog to save a file.

        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.

        Returns:
            str: The path where the file is to be saved.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying save file dialog&#34;)
        return filedialog.asksaveasfilename(*args, **kwargs)

    def show_askyesno(self, title: str, message: str) -&gt; bool:
        &#34;&#34;&#34;
        Displays a Yes/No dialog.

        Args:
            title (str): The title of the dialog.
            message (str): The message to be displayed in the dialog.

        Returns:
            bool: The answer of the user (True for &#39;Yes&#39;, False for &#39;No&#39;).
        &#34;&#34;&#34;

        logger.info(&#34;Displaying yes/no dialog&#34;)
        return messagebox.askyesno(title, message)

    def show_error(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays an error message dialog.

        Args:
            message (str): The error message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying error message&#34;)
        messagebox.showerror(&#34;Error&#34;, inspect.cleandoc(message))

    def show_info(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays an informational message dialog.

        Args:
            message (str): The informational message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying info message&#34;)
        messagebox.showinfo(&#34;Info&#34;, inspect.cleandoc(message))

    def show_warning(self, message: str) -&gt; None:
        &#34;&#34;&#34;
        Displays a warning message dialog.

        Args:
            message (str): The warning message to be displayed.
        &#34;&#34;&#34;

        logger.info(&#34;Displaying warning message&#34;)
        messagebox.showwarning(&#34;Warning&#34;, inspect.cleandoc(message))

    ### ----------------------- Treeview Selections ----------------------- ###
    def selected_match_responses(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected responses from the `match_results_tree` Treeview.

        Returns:
            set[str]: The selected responses.
        &#34;&#34;&#34;

        return {
            self.match_results_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.match_results_tree.selection()
        }

    def selected_category_responses(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected responses from the `category_results_tree` Treeview.

        Returns:
            set[str]: The selected responses.
        &#34;&#34;&#34;

        return {
            self.category_results_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.category_results_tree.selection()
        }

    def selected_categories(self) -&gt; set[str]:
        &#34;&#34;&#34;
        Returns a set of selected categories from the `categories_tree` Treeview.

        Returns:
            set[str]: The selected categories.
        &#34;&#34;&#34;

        return {
            self.categories_tree.item(item_id)[&#34;values&#34;][0]
            for item_id in self.categories_tree.selection()
        }

    def update_treeview_selections(
        self, selected_categories: set[str] = set(), selected_responses: set[str] = set()
    ) -&gt; None:
        &#34;&#34;&#34;
        Updates the selections in Treeview widgets based on specified criteria.

        Args:
            selected_categories (set[str], optional): A set of category names to be re-selected in the `categories_tree`.
            selected_responses (set[str], optional): A set of responses to be re-selected in the `match_results_tree`
                if categorization_type is &#39;Multi&#39;.
        &#34;&#34;&#34;

        def reselect_treeview_items(treeview, values):
            for item in treeview.get_children():
                if treeview.item(item)[&#34;values&#34;][0] in values:
                    treeview.selection_add(item)

        # Re-select categories and if multi-categorization re-select match results
        logger.info(&#34;Updating treeview selections&#34;)
        if selected_categories is not None:
            reselect_treeview_items(self.categories_tree, selected_categories)
        if self.categorization_type.get() == &#34;Multi&#34; and selected_responses is not None:
            reselect_treeview_items(self.match_results_tree, selected_responses)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Tk</li>
<li>tkinter.Misc</li>
<li>tkinter.Wm</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.fuzzy_ui.FuzzyUI.configure_frames"><code class="name flex">
<span>def <span class="ident">configure_frames</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates frames for different sections of the UI and positions them within the main window grid.
<code>self.frames</code> is a dictionary of position names (e.g. "top_left") to frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_frames(self) -&gt; None:
    &#34;&#34;&#34;
    Creates frames for different sections of the UI and positions them within the main window grid.
    `self.frames` is a dictionary of position names (e.g. &#34;top_left&#34;) to frames.
    &#34;&#34;&#34;

    self.frames = {}

    positions = [
        &#34;top_left&#34;,
        &#34;middle_left&#34;,
        &#34;bottom_left&#34;,
        &#34;top_middle&#34;,
        &#34;middle_middle&#34;,
        &#34;bottom_middle&#34;,
        &#34;top_right&#34;,
        &#34;middle_right&#34;,
        &#34;bottom_right&#34;,
    ]

    for position in positions:
        self.frames[position] = tk.Frame(self)

    self.frames[&#34;top_left&#34;].grid(row=0, column=0, sticky=&#34;sew&#34;, padx=10, pady=10)
    self.frames[&#34;middle_left&#34;].grid(row=1, column=0, sticky=&#34;nsew&#34;, padx=10, pady=10)
    self.frames[&#34;bottom_left&#34;].grid(row=2, column=0, sticky=&#34;new&#34;, padx=10, pady=10)
    self.frames[&#34;top_middle&#34;].grid(row=0, column=1, sticky=&#34;sew&#34;, padx=10, pady=10)
    self.frames[&#34;middle_middle&#34;].grid(row=1, column=1, sticky=&#34;nsew&#34;, padx=10, pady=10)
    self.frames[&#34;bottom_middle&#34;].grid(row=2, column=1, sticky=&#34;new&#34;, padx=10, pady=10)
    self.frames[&#34;top_right&#34;].grid(row=0, column=2, sticky=&#34;sew&#34;, padx=10, pady=10)
    self.frames[&#34;middle_right&#34;].grid(row=1, column=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
    self.frames[&#34;bottom_right&#34;].grid(row=2, column=2, sticky=&#34;new&#34;, padx=10, pady=10)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.configure_grid"><code class="name flex">
<span>def <span class="ident">configure_grid</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the main window grid layout, defining how frames will be placed and resized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_grid(self) -&gt; None:
    &#34;&#34;&#34;
    Configures the main window grid layout, defining how frames will be placed and resized.
    &#34;&#34;&#34;

    self.grid_columnconfigure(0, weight=1)  # Fuzzy matching
    self.grid_columnconfigure(1, weight=1)  # Category results
    self.grid_columnconfigure(2, weight=1)  # Categories display
    self.grid_rowconfigure(0, weight=0)  # Buttons, entries, labels, etc
    self.grid_rowconfigure(1, weight=1)  # Treeviews
    self.grid_rowconfigure(2, weight=0)  # Project management
    # Weights set such that all columns and only middle row can expand/contract</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.configure_style"><code class="name flex">
<span>def <span class="ident">configure_style</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Configure global properties of the interface, such as Treeview row height and text alignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_style(self) -&gt; None:
    &#34;&#34;&#34;
    Configure global properties of the interface, such as Treeview row height and text alignment.
    &#34;&#34;&#34;

    # Configure Treeview style for larger row height and centered column text
    style = ttk.Style(self)
    style.configure(&#34;Treeview&#34;, rowheight=25)
    style.configure(&#34;Treeview.Item&#34;, anchor=&#34;center&#34;)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.configure_sub_grids"><code class="name flex">
<span>def <span class="ident">configure_sub_grids</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the grid layouts within individual frames, ensuring proper alignment and sizing of widgets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_sub_grids(self) -&gt; None:
    &#34;&#34;&#34;
    Configures the grid layouts within individual frames, ensuring proper alignment and sizing of widgets.
    &#34;&#34;&#34;

    # Allow all buttons and treviews to expand/contract horizontally together
    for frame in self.frames.values():
        for col in range(frame.grid_size()[0]):
            frame.grid_columnconfigure(col, weight=1)

    for frame in [
        self.frames[&#34;middle_left&#34;],
        self.frames[&#34;middle_middle&#34;],
        self.frames[&#34;middle_right&#34;],
    ]:
        # Don&#39;t allow the scrollbars to expand horizontally
        last_column = frame.grid_size()[0] - 1
        frame.grid_columnconfigure(last_column, weight=0)
        # Allow the treeviews to expand vertically
        frame.grid_rowconfigure(0, weight=1)

    # Allow the bottom left frame buttons to group together on the left
    self.frames[&#34;bottom_left&#34;].grid_columnconfigure(0, weight=0)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.create_ask_categorization_type_popup"><code class="name flex">
<span>def <span class="ident">create_ask_categorization_type_popup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a popup window that allows the user to select the categorization type (Single or Multi).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ask_categorization_type_popup(self):
    &#34;&#34;&#34;
    Creates a popup window that allows the user to select the categorization type (Single or Multi).
    &#34;&#34;&#34;

    logger.info(&#34;Creating categorization type popup&#34;)
    self.categorization_type_popup = self.create_popup(&#34;Select Categorization Type&#34;)

    # Create buttons that assign value to self.categoriztation_type
    single_categorization_rb = tk.Radiobutton(
        self.categorization_type_popup,
        text=&#34;Single Categorization&#34;,
        variable=self.categorization_type,
        value=&#34;Single&#34;,
    )
    multi_categorization_rb = tk.Radiobutton(
        self.categorization_type_popup,
        text=&#34;Multi Categorization&#34;,
        variable=self.categorization_type,
        value=&#34;Multi&#34;,
    )
    self.confirm_button = tk.Button(
        self.categorization_type_popup,
        text=&#34;Confirm&#34;,
    )

    # Functions to execute upon confirm/Enter
    def _on_confirm():
        self.set_categorization_type_label()
        self.categorization_type_popup.destroy()

    # Bind widgets to commands
    self.confirm_button.bind(&#34;&lt;Button-1&gt;&#34;, lambda event: _on_confirm())
    self.categorization_type_popup.bind(&#34;&lt;Return&gt;&#34;, lambda event: _on_confirm())

    # Add the buttons to the window
    single_categorization_rb.pack()
    multi_categorization_rb.pack()
    self.confirm_button.pack()</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.create_popup"><code class="name flex">
<span>def <span class="ident">create_popup</span></span>(<span>self, title:Â str) â€‘>Â tkinter.Toplevel</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a general-purpose popup window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the popup window.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tk.Toplevel</code></dt>
<dd>The created popup window.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_popup(self, title: str) -&gt; tk.Toplevel:
    &#34;&#34;&#34;
    Creates a general-purpose popup window.

    Args:
        title (str): The title of the popup window.

    Returns:
        tk.Toplevel: The created popup window.
    &#34;&#34;&#34;

    popup = tk.Toplevel(self)
    popup.title(title)

    # Center the popup on the main window
    self.POPUP_WIDTH = &#34;400&#34;
    self.POPUP_HEIGHT = &#34;200&#34;
    popup.geometry(f&#34;{self.POPUP_WIDTH}x{self.POPUP_HEIGHT}+{self.centre_x}+{self.centre_y}&#34;)

    # Keep the popup window on top
    # Ensure all events are directed to this window until closed
    # Set focus on this popup so that you can straight away press enter
    popup.transient(self)
    popup.grab_set()
    popup.focus_set()

    return popup</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.create_rename_category_popup"><code class="name flex">
<span>def <span class="ident">create_rename_category_popup</span></span>(<span>self, old_category:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a popup window for renaming a category.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>old_category</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the category to be renamed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rename_category_popup(self, old_category: str) -&gt; None:
    &#34;&#34;&#34;
    Creates a popup window for renaming a category.

    Args:
        old_category (str): The name of the category to be renamed.
    &#34;&#34;&#34;

    logger.info(&#34;Creating rename category popup&#34;)
    self.rename_dialog_popup = self.create_popup(&#34;Rename Category&#34;)

    # Create widgets
    self.label = tk.Label(
        self.rename_dialog_popup, text=f&#34;Enter a new name for &#39;{old_category}&#39;:&#34;
    )
    self.rename_category_entry = tk.Entry(self.rename_dialog_popup)
    self.ok_button = tk.Button(self.rename_dialog_popup, text=&#34;OK&#34;)
    self.cancel_button = tk.Button(self.rename_dialog_popup, text=&#34;Cancel&#34;)

    # Add widgets to popup
    self.label.pack(pady=10)
    self.rename_category_entry.pack()
    self.ok_button.pack(side=&#34;left&#34;, padx=20)
    self.cancel_button.pack(side=&#34;right&#34;, padx=20)

    # Set focus to the string entry
    self.rename_category_entry.focus_set()</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.create_widgets"><code class="name flex">
<span>def <span class="ident">create_widgets</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates various UI widgets (buttons, labels, entries, treeviews, etc.) and assigns them to frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_widgets(self) -&gt; None:
    &#34;&#34;&#34;
    Creates various UI widgets (buttons, labels, entries, treeviews, etc.) and assigns them to frames.
    &#34;&#34;&#34;

    # Top left frame widgets (fuzzy matching entry, slider, buttons and lable)
    self.match_string_label = tk.Label(self.frames[&#34;top_left&#34;], text=&#34;Enter String to Match:&#34;)
    self.match_string_entry = tk.Entry(self.frames[&#34;top_left&#34;])
    self.threshold_label = tk.Label(
        self.frames[&#34;top_left&#34;],
        text=&#34;Set Fuzz Threshold (100 is precise, 0 is imprecise):&#34;,
    )
    self.threshold_slider = tk.Scale(
        self.frames[&#34;top_left&#34;], from_=0, to=100, orient=&#34;horizontal&#34;, resolution=1
    )
    self.threshold_slider.set(60)  # Setting default value to 60, gets decent results
    self.match_button = tk.Button(self.frames[&#34;top_left&#34;], text=&#34;Match&#34;)
    self.categorize_button = tk.Button(
        self.frames[&#34;top_left&#34;], text=&#34;Categorize Selected Results&#34;
    )
    self.categorization_label = tk.Label(
        self.frames[&#34;top_left&#34;], text=&#34;Categorization Type: Single&#34;
    )

    # Middle left frame widgets (fuzzy matching treeview)
    self.match_results_tree = ttk.Treeview(
        self.frames[&#34;middle_left&#34;],
        columns=(&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;),
        show=&#34;headings&#34;,
    )
    for col in [&#34;Response&#34;, &#34;Score&#34;, &#34;Count&#34;]:
        self.match_results_tree.heading(col, text=col)
        if col != &#34;Response&#34;:
            self.match_results_tree.column(col, anchor=&#34;center&#34;)
    self.results_scrollbar = tk.Scrollbar(
        self.frames[&#34;middle_left&#34;],
        orient=&#34;vertical&#34;,
        command=self.match_results_tree.yview,
    )

    # Bottom left frame widgets (new project, load project, append data)
    self.new_project_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;New Project&#34;)
    self.load_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Load Project&#34;)
    self.append_data_button = tk.Button(self.frames[&#34;bottom_left&#34;], text=&#34;Append Data&#34;)

    # Top middle frame widgets (category results buttons and labels)
    self.display_category_results_for_selected_category_button = tk.Button(
        self.frames[&#34;top_middle&#34;], text=&#34;Display Category Results&#34;
    )
    self.recategorize_selected_responses_button = tk.Button(
        self.frames[&#34;top_middle&#34;], text=&#34;Recategorize Selected Results&#34;
    )
    self.category_results_label = tk.Label(
        self.frames[&#34;top_middle&#34;], text=&#34;Results for Category: &#34;
    )

    # Middle middle frame widgets (category results treeview)
    self.category_results_tree = ttk.Treeview(
        self.frames[&#34;middle_middle&#34;], columns=(&#34;Response&#34;, &#34;Count&#34;), show=&#34;headings&#34;
    )
    self.category_results_tree.heading(&#34;Response&#34;, text=&#34;Response&#34;)
    self.category_results_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
    self.category_results_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
    self.category_results_scrollbar = tk.Scrollbar(
        self.frames[&#34;middle_middle&#34;],
        orient=&#34;vertical&#34;,
        command=self.category_results_tree.yview,
    )

    # Bottom middle frame widgets (None)

    # Top right frame widgets (category buttons and entry)
    self.new_category_entry = tk.Entry(self.frames[&#34;top_right&#34;])
    self.add_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Add Category&#34;)
    self.rename_category_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Rename Category&#34;)
    self.delete_categories_button = tk.Button(self.frames[&#34;top_right&#34;], text=&#34;Delete Category&#34;)
    self.delete_categories_button.bind()
    self.include_missing_data_checkbox = tk.Checkbutton(
        self.frames[&#34;top_right&#34;],
        text=&#34;Base to total&#34;,
        variable=self.is_including_missing_data,
    )

    # Middle right frame widgets (categories treeview)
    self.categories_tree = ttk.Treeview(
        self.frames[&#34;middle_right&#34;],
        columns=(&#34;Category&#34;, &#34;Count&#34;, &#34;Percentage&#34;),
        show=&#34;headings&#34;,
    )
    self.categories_tree.heading(&#34;Category&#34;, text=&#34;Category&#34;)
    self.categories_tree.heading(&#34;Count&#34;, text=&#34;Count&#34;)
    self.categories_tree.heading(&#34;Percentage&#34;, text=&#34;%&#34;)
    self.categories_tree.column(&#34;Count&#34;, anchor=&#34;center&#34;)
    self.categories_tree.column(&#34;Percentage&#34;, anchor=&#34;center&#34;)
    self.categories_scrollbar = tk.Scrollbar(
        self.frames[&#34;middle_right&#34;],
        orient=&#34;vertical&#34;,
        command=self.categories_tree.yview,
    )

    # Bottom right frame widgets (new project, load project, save project, export to csv)
    self.export_csv_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Export to CSV&#34;)
    self.save_button = tk.Button(self.frames[&#34;bottom_right&#34;], text=&#34;Save Project&#34;)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.display_categories"><code class="name flex">
<span>def <span class="ident">display_categories</span></span>(<span>self, formatted_categories_metrics:Â list[typing.Tuple[str,Â int,Â str]]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the list of categories and related metrics in the <code>categories_tree</code> Treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>formatted_categories_metrics</code></strong> :&ensp;<code>list[Tuple[str, int, str]]</code></dt>
<dd>An list of tuples, each containing the category name,
count of responses, and the percentage as a string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_categories(self, formatted_categories_metrics: list[Tuple[str, int, str]]) -&gt; None:
    &#34;&#34;&#34;
    Displays the list of categories and related metrics in the `categories_tree` Treeview.

    Args:
        formatted_categories_metrics (list[Tuple[str, int, str]]): An list of tuples, each containing the category name,
            count of responses, and the percentage as a string.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying categories and metrics&#34;)
    selected_categories = self.selected_categories()

    for item in self.categories_tree.get_children():
        self.categories_tree.delete(item)

    for category, count, percentage_str in formatted_categories_metrics:
        self.categories_tree.insert(&#34;&#34;, &#34;end&#34;, values=(category, count, percentage_str))

    self.update_treeview_selections(selected_categories=selected_categories)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.display_category_results"><code class="name flex">
<span>def <span class="ident">display_category_results</span></span>(<span>self, category:Â str, responses_and_counts:Â list[typing.Tuple[str,Â int]]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the results for a specific category in the <code>category_results_tree</code> Treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the category for which results are being displayed.</dd>
<dt><strong><code>responses_and_counts</code></strong> :&ensp;<code>list[Tuple[str, int]]</code></dt>
<dd>A list of tuples, each containing a response and the count of occurances.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_category_results(
    self, category: str, responses_and_counts: list[Tuple[str, int]]
) -&gt; None:
    &#34;&#34;&#34;
    Displays the results for a specific category in the `category_results_tree` Treeview.

    Args:
        category (str): The name of the category for which results are being displayed.
        responses_and_counts (list[Tuple[str, int]]): A list of tuples, each containing a response and the count of occurances.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying category results&#34;)
    for item in self.category_results_tree.get_children():
        self.category_results_tree.delete(item)

    for response, count in responses_and_counts:
        self.category_results_tree.insert(&#34;&#34;, &#34;end&#34;, values=(response, count))

    self.category_results_label.config(text=f&#34;Results for Category: {category}&#34;)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.display_fuzzy_match_results"><code class="name flex">
<span>def <span class="ident">display_fuzzy_match_results</span></span>(<span>self, processed_results:Â pandas.core.frame.DataFrame) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the results of fuzzy matching in the <code>match_results_tree</code> Treeview.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>processed_results</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the fuzzy match results.
Expected to contain 'response', 'score', and 'count' columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_fuzzy_match_results(self, processed_results: pd.DataFrame) -&gt; None:
    &#34;&#34;&#34;
    Displays the results of fuzzy matching in the `match_results_tree` Treeview.

    Args:
        processed_results (pd.DataFrame): A DataFrame containing the fuzzy match results.
            Expected to contain &#39;response&#39;, &#39;score&#39;, and &#39;count&#39; columns.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying fuzzy match results&#34;)
    for item in self.match_results_tree.get_children():
        self.match_results_tree.delete(item)

    for _, row in processed_results.iterrows():
        self.match_results_tree.insert(
            &#34;&#34;, &#34;end&#34;, values=(row[&#34;response&#34;], row[&#34;score&#34;], row[&#34;count&#34;])
        )</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.initialize_window"><code class="name flex">
<span>def <span class="ident">initialize_window</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the main window with the same aspect ratio as your screen (augmented by <code>WINDOW_SIZE_MULTIPLIER</code>).
Places it at the center of the screen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_window(self) -&gt; None:
    &#34;&#34;&#34;
    Initializes the main window with the same aspect ratio as your screen (augmented by `WINDOW_SIZE_MULTIPLIER`).
    Places it at the center of the screen.
    &#34;&#34;&#34;

    self.geometry(f&#34;{self.window_width}x{self.window_height}+{self.centre_x}+{self.centre_y}&#34;)
    # self.state(&#39;zoomed&#39;)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.on_window_resize"><code class="name flex">
<span>def <span class="ident">on_window_resize</span></span>(<span>self, event) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Handles window resize events, resizing Treeview columns and text wrap lengths accordingly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong></dt>
<dd>The resize event object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_window_resize(self, event) -&gt; None:
    &#34;&#34;&#34;
    Handles window resize events, resizing Treeview columns and text wrap lengths accordingly.

    Args:
        event: The resize event object.
    &#34;&#34;&#34;

    self.resize_treeview_columns()
    self.resize_text_wraplength()</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.position_widgets_in_frames"><code class="name flex">
<span>def <span class="ident">position_widgets_in_frames</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Positions the created widgets within their respective frames, defining layout properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_widgets_in_frames(self) -&gt; None:
    &#34;&#34;&#34;
    Positions the created widgets within their respective frames, defining layout properties.
    &#34;&#34;&#34;

    # Top left frame widgets
    self.match_string_label.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
    self.match_string_entry.grid(row=1, column=0, sticky=&#34;ew&#34;, padx=5)
    self.threshold_label.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
    self.threshold_slider.grid(row=1, column=1, sticky=&#34;ew&#34;, padx=5)
    self.categorization_label.grid(row=2, column=1, sticky=&#34;ew&#34;)
    self.match_button.grid(row=3, column=0, sticky=&#34;ew&#34;, padx=10, pady=10)
    self.categorize_button.grid(row=3, column=1, sticky=&#34;ew&#34;, padx=10, pady=10)

    # Middle left frame widgets
    self.match_results_tree.grid(row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10)
    self.results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
    self.match_results_tree.configure(yscrollcommand=self.results_scrollbar.set)

    # Bottom left frame widgets
    self.new_project_button.grid(row=0, column=0, sticky=&#34;w&#34;, padx=10, pady=10)
    self.append_data_button.grid(row=0, column=1, sticky=&#34;w&#34;, padx=10, pady=10)
    self.load_button.grid(row=1, column=0, sticky=&#34;w&#34;, padx=10, pady=10)

    # Top middle frame widgets
    self.display_category_results_for_selected_category_button.grid(
        row=0, column=0, sticky=&#34;ew&#34;, padx=10, pady=10
    )
    self.recategorize_selected_responses_button.grid(
        row=0, column=1, sticky=&#34;ew&#34;, padx=10, pady=10
    )
    self.category_results_label.grid(
        row=1, column=0, columnspan=2, sticky=&#34;ew&#34;, padx=10, pady=10
    )

    # Middle middle frame widgets
    self.category_results_tree.grid(
        row=0, column=0, columnspan=2, sticky=&#34;nsew&#34;, padx=10, pady=10
    )
    self.category_results_scrollbar.grid(row=0, column=2, sticky=&#34;ns&#34;)
    self.category_results_tree.configure(yscrollcommand=self.category_results_scrollbar.set)

    # Bottm middle frame widgets

    # Top right frame widgets
    self.new_category_entry.grid(row=0, column=0, sticky=&#34;ew&#34;, padx=5)
    self.add_category_button.grid(row=0, column=1, sticky=&#34;ew&#34;, padx=5)
    self.rename_category_button.grid(row=0, column=2, sticky=&#34;ew&#34;, padx=5)
    self.delete_categories_button.grid(row=0, column=3, sticky=&#34;ew&#34;, padx=5)
    self.include_missing_data_checkbox.grid(row=1, column=3, sticky=&#34;e&#34;)

    # Middle right frame widgets
    self.categories_tree.grid(row=0, column=0, columnspan=4, sticky=&#34;nsew&#34;, padx=10, pady=10)
    self.categories_scrollbar.grid(row=0, column=4, sticky=&#34;ns&#34;)
    self.categories_tree.configure(yscrollcommand=self.categories_scrollbar.set)

    # Bottom right frame widgets
    self.export_csv_button.grid(row=0, column=0, sticky=&#34;e&#34;, padx=10, pady=10)
    self.save_button.grid(row=1, column=0, sticky=&#34;e&#34;, padx=10, pady=10)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.resize_text_wraplength"><code class="name flex">
<span>def <span class="ident">resize_text_wraplength</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Adjusts the wrap length of text in labels, buttons, and radio buttons when the main window is resized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_text_wraplength(self) -&gt; None:
    &#34;&#34;&#34;
    Adjusts the wrap length of text in labels, buttons, and radio buttons when the main window is resized.
    &#34;&#34;&#34;

    for frame in self.winfo_children():
        for widget in frame.winfo_children():
            if isinstance(widget, (tk.Label, tk.Button, tk.Radiobutton)):
                # Extra added to make it slightly less eager to resize
                width = widget.winfo_width() + 10
                widget.configure(wraplength=width)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.resize_treeview_columns"><code class="name flex">
<span>def <span class="ident">resize_treeview_columns</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Adjusts the width of Treeview columns based on the width of the Treeview widget during window resizing.</p>
<p>Each column after the first one is set to 1/6th the total treeview width, and the first one takes the remaining space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize_treeview_columns(self) -&gt; None:
    &#34;&#34;&#34;
    Adjusts the width of Treeview columns based on the width of the Treeview widget during window resizing.

    Each column after the first one is set to 1/6th the total treeview width, and the first one takes the remaining space.
    &#34;&#34;&#34;

    for frame in self.winfo_children():
        for widget in frame.winfo_children():
            if isinstance(widget, ttk.Treeview):
                treeview = widget
                treeview_width = treeview.winfo_width()

                num_columns = len(treeview[&#34;columns&#34;])
                if num_columns &gt; 1:
                    # Each column after the first one is set to 1/6th the total treeview width
                    # The first one takes the remaining space.
                    secondary_column_width = treeview_width // 6
                    first_column_width = treeview_width - (
                        secondary_column_width * (num_columns - 1)
                    )

                    treeview.column(treeview[&#34;columns&#34;][0], width=first_column_width)
                    for col in treeview[&#34;columns&#34;][1:]:
                        treeview.column(col, minwidth=50, width=secondary_column_width)
                else:
                    # If there is only one column, it should take all the space
                    treeview.column(treeview[&#34;columns&#34;][0], width=treeview_width)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.selected_categories"><code class="name flex">
<span>def <span class="ident">selected_categories</span></span>(<span>self) â€‘>Â set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set of selected categories from the <code>categories_tree</code> Treeview.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>The selected categories.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selected_categories(self) -&gt; set[str]:
    &#34;&#34;&#34;
    Returns a set of selected categories from the `categories_tree` Treeview.

    Returns:
        set[str]: The selected categories.
    &#34;&#34;&#34;

    return {
        self.categories_tree.item(item_id)[&#34;values&#34;][0]
        for item_id in self.categories_tree.selection()
    }</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.selected_category_responses"><code class="name flex">
<span>def <span class="ident">selected_category_responses</span></span>(<span>self) â€‘>Â set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set of selected responses from the <code>category_results_tree</code> Treeview.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>The selected responses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selected_category_responses(self) -&gt; set[str]:
    &#34;&#34;&#34;
    Returns a set of selected responses from the `category_results_tree` Treeview.

    Returns:
        set[str]: The selected responses.
    &#34;&#34;&#34;

    return {
        self.category_results_tree.item(item_id)[&#34;values&#34;][0]
        for item_id in self.category_results_tree.selection()
    }</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.selected_match_responses"><code class="name flex">
<span>def <span class="ident">selected_match_responses</span></span>(<span>self) â€‘>Â set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set of selected responses from the <code>match_results_tree</code> Treeview.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>The selected responses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selected_match_responses(self) -&gt; set[str]:
    &#34;&#34;&#34;
    Returns a set of selected responses from the `match_results_tree` Treeview.

    Returns:
        set[str]: The selected responses.
    &#34;&#34;&#34;

    return {
        self.match_results_tree.item(item_id)[&#34;values&#34;][0]
        for item_id in self.match_results_tree.selection()
    }</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.set_categorization_type_label"><code class="name flex">
<span>def <span class="ident">set_categorization_type_label</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets <code>categorization_type_label</code> to reflect the current value of the <code>categorization_type</code> variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_categorization_type_label(self) -&gt; None:
    &#34;&#34;&#34;
    Sets `categorization_type_label` to reflect the current value of the `categorization_type` variable.
    &#34;&#34;&#34;

    logger.info(&#34;Setting categorization type label&#34;)
    chosen_type = self.categorization_type.get()
    self.categorization_label.config(text=&#34;Categorization Type: &#34; + chosen_type)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_askyesno"><code class="name flex">
<span>def <span class="ident">show_askyesno</span></span>(<span>self, title:Â str, message:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a Yes/No dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title of the dialog.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to be displayed in the dialog.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>The answer of the user (True for 'Yes', False for 'No').</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_askyesno(self, title: str, message: str) -&gt; bool:
    &#34;&#34;&#34;
    Displays a Yes/No dialog.

    Args:
        title (str): The title of the dialog.
        message (str): The message to be displayed in the dialog.

    Returns:
        bool: The answer of the user (True for &#39;Yes&#39;, False for &#39;No&#39;).
    &#34;&#34;&#34;

    logger.info(&#34;Displaying yes/no dialog&#34;)
    return messagebox.askyesno(title, message)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_error"><code class="name flex">
<span>def <span class="ident">show_error</span></span>(<span>self, message:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays an error message dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The error message to be displayed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_error(self, message: str) -&gt; None:
    &#34;&#34;&#34;
    Displays an error message dialog.

    Args:
        message (str): The error message to be displayed.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying error message&#34;)
    messagebox.showerror(&#34;Error&#34;, inspect.cleandoc(message))</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_info"><code class="name flex">
<span>def <span class="ident">show_info</span></span>(<span>self, message:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays an informational message dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The informational message to be displayed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_info(self, message: str) -&gt; None:
    &#34;&#34;&#34;
    Displays an informational message dialog.

    Args:
        message (str): The informational message to be displayed.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying info message&#34;)
    messagebox.showinfo(&#34;Info&#34;, inspect.cleandoc(message))</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_open_file_dialog"><code class="name flex">
<span>def <span class="ident">show_open_file_dialog</span></span>(<span>self, *args, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a dialog to open a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Variable length argument list.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Arbitrary keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The path of the selected file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_open_file_dialog(self, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Displays a dialog to open a file.

    Args:
        *args: Variable length argument list.
        **kwargs: Arbitrary keyword arguments.

    Returns:
        str: The path of the selected file.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying open file dialog&#34;)
    return filedialog.askopenfilename(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_save_file_dialog"><code class="name flex">
<span>def <span class="ident">show_save_file_dialog</span></span>(<span>self, *args, **kwargs) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a dialog to save a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Variable length argument list.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Arbitrary keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The path where the file is to be saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_save_file_dialog(self, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Displays a dialog to save a file.

    Args:
        *args: Variable length argument list.
        **kwargs: Arbitrary keyword arguments.

    Returns:
        str: The path where the file is to be saved.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying save file dialog&#34;)
    return filedialog.asksaveasfilename(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.show_warning"><code class="name flex">
<span>def <span class="ident">show_warning</span></span>(<span>self, message:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a warning message dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The warning message to be displayed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_warning(self, message: str) -&gt; None:
    &#34;&#34;&#34;
    Displays a warning message dialog.

    Args:
        message (str): The warning message to be displayed.
    &#34;&#34;&#34;

    logger.info(&#34;Displaying warning message&#34;)
    messagebox.showwarning(&#34;Warning&#34;, inspect.cleandoc(message))</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.update_coords"><code class="name flex">
<span>def <span class="ident">update_coords</span></span>(<span>self, screen_width:Â int, screen_height:Â int) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the main window's position and size based on the screen dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>screen_width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the screen. Used with self.winfo_screenwidth().</dd>
<dt><strong><code>screen_height</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the screen. Used with self.winfo_screenheight().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_coords(self, screen_width: int, screen_height: int) -&gt; None:
    &#34;&#34;&#34;
    Updates the main window&#39;s position and size based on the screen dimensions.

    Args:
        screen_width (int): The width of the screen. Used with self.winfo_screenwidth().
        screen_height (int): The height of the screen. Used with self.winfo_screenheight().
    &#34;&#34;&#34;

    self.screen_width = screen_width
    self.screen_height = screen_height
    self.window_width = int(screen_width * self.WINDOW_SIZE_MULTIPLIER)
    self.window_height = int(screen_height * self.WINDOW_SIZE_MULTIPLIER)
    self.centre_x = int((screen_width - self.window_width) / 2)
    self.centre_y = int((screen_height - self.window_height) / 2)</code></pre>
</details>
</dd>
<dt id="src.fuzzy_ui.FuzzyUI.update_treeview_selections"><code class="name flex">
<span>def <span class="ident">update_treeview_selections</span></span>(<span>self, selected_categories:Â set[str]Â =Â set(), selected_responses:Â set[str]Â =Â set()) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the selections in Treeview widgets based on specified criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selected_categories</code></strong> :&ensp;<code>set[str]</code>, optional</dt>
<dd>A set of category names to be re-selected in the <code>categories_tree</code>.</dd>
<dt><strong><code>selected_responses</code></strong> :&ensp;<code>set[str]</code>, optional</dt>
<dd>A set of responses to be re-selected in the <code>match_results_tree</code>
if categorization_type is 'Multi'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_treeview_selections(
    self, selected_categories: set[str] = set(), selected_responses: set[str] = set()
) -&gt; None:
    &#34;&#34;&#34;
    Updates the selections in Treeview widgets based on specified criteria.

    Args:
        selected_categories (set[str], optional): A set of category names to be re-selected in the `categories_tree`.
        selected_responses (set[str], optional): A set of responses to be re-selected in the `match_results_tree`
            if categorization_type is &#39;Multi&#39;.
    &#34;&#34;&#34;

    def reselect_treeview_items(treeview, values):
        for item in treeview.get_children():
            if treeview.item(item)[&#34;values&#34;][0] in values:
                treeview.selection_add(item)

    # Re-select categories and if multi-categorization re-select match results
    logger.info(&#34;Updating treeview selections&#34;)
    if selected_categories is not None:
        reselect_treeview_items(self.categories_tree, selected_categories)
    if self.categorization_type.get() == &#34;Multi&#34; and selected_responses is not None:
        reselect_treeview_items(self.match_results_tree, selected_responses)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.fuzzy_ui.FuzzyUI" href="#src.fuzzy_ui.FuzzyUI">FuzzyUI</a></code></h4>
<ul class="">
<li><code><a title="src.fuzzy_ui.FuzzyUI.configure_frames" href="#src.fuzzy_ui.FuzzyUI.configure_frames">configure_frames</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.configure_grid" href="#src.fuzzy_ui.FuzzyUI.configure_grid">configure_grid</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.configure_style" href="#src.fuzzy_ui.FuzzyUI.configure_style">configure_style</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.configure_sub_grids" href="#src.fuzzy_ui.FuzzyUI.configure_sub_grids">configure_sub_grids</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.create_ask_categorization_type_popup" href="#src.fuzzy_ui.FuzzyUI.create_ask_categorization_type_popup">create_ask_categorization_type_popup</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.create_popup" href="#src.fuzzy_ui.FuzzyUI.create_popup">create_popup</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.create_rename_category_popup" href="#src.fuzzy_ui.FuzzyUI.create_rename_category_popup">create_rename_category_popup</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.create_widgets" href="#src.fuzzy_ui.FuzzyUI.create_widgets">create_widgets</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.display_categories" href="#src.fuzzy_ui.FuzzyUI.display_categories">display_categories</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.display_category_results" href="#src.fuzzy_ui.FuzzyUI.display_category_results">display_category_results</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.display_fuzzy_match_results" href="#src.fuzzy_ui.FuzzyUI.display_fuzzy_match_results">display_fuzzy_match_results</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.initialize_window" href="#src.fuzzy_ui.FuzzyUI.initialize_window">initialize_window</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.on_window_resize" href="#src.fuzzy_ui.FuzzyUI.on_window_resize">on_window_resize</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.position_widgets_in_frames" href="#src.fuzzy_ui.FuzzyUI.position_widgets_in_frames">position_widgets_in_frames</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.resize_text_wraplength" href="#src.fuzzy_ui.FuzzyUI.resize_text_wraplength">resize_text_wraplength</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.resize_treeview_columns" href="#src.fuzzy_ui.FuzzyUI.resize_treeview_columns">resize_treeview_columns</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.selected_categories" href="#src.fuzzy_ui.FuzzyUI.selected_categories">selected_categories</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.selected_category_responses" href="#src.fuzzy_ui.FuzzyUI.selected_category_responses">selected_category_responses</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.selected_match_responses" href="#src.fuzzy_ui.FuzzyUI.selected_match_responses">selected_match_responses</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.set_categorization_type_label" href="#src.fuzzy_ui.FuzzyUI.set_categorization_type_label">set_categorization_type_label</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_askyesno" href="#src.fuzzy_ui.FuzzyUI.show_askyesno">show_askyesno</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_error" href="#src.fuzzy_ui.FuzzyUI.show_error">show_error</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_info" href="#src.fuzzy_ui.FuzzyUI.show_info">show_info</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_open_file_dialog" href="#src.fuzzy_ui.FuzzyUI.show_open_file_dialog">show_open_file_dialog</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_save_file_dialog" href="#src.fuzzy_ui.FuzzyUI.show_save_file_dialog">show_save_file_dialog</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.show_warning" href="#src.fuzzy_ui.FuzzyUI.show_warning">show_warning</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.update_coords" href="#src.fuzzy_ui.FuzzyUI.update_coords">update_coords</a></code></li>
<li><code><a title="src.fuzzy_ui.FuzzyUI.update_treeview_selections" href="#src.fuzzy_ui.FuzzyUI.update_treeview_selections">update_treeview_selections</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>