import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import ctypes
import pandas as pd
import re
import chardet
from thefuzz import fuzz

# Set DPI Awareness
ctypes.windll.shcore.SetProcessDpiAwareness(1)

def file_import(file_path):
    with open(file_path, 'rb') as file:
        encoding = chardet.detect(file.read())['encoding']
    df = pd.read_csv(file_path, encoding=encoding)
    return df

def preprocess_text(text):
    # Lowercase, remove leading and trailing white space
    text = str(text).lower().strip()
    # Remove special characters
    text = re.sub(r'[^a-z0-9\s]', '', text)
    return text

def fuzzy_matching(df_preprocessed, match_string_entry):
    match_string = match_string_entry.get()
    # Fuzzy match element with given string
    def fuzzy_match(element):
        return fuzz.WRatio(match_string, str(element))

    # Get fuzzy matching scores and format result: (response, score)
    results = []
    for row in df_preprocessed.itertuples(index=True, name=None):
        for response in row[1:]:
            score = fuzzy_match(response)
            # Append a dictionary for each matching record
            results.append({'response': response, 'score': score})

    # Convert list of dictionaries to DataFrame
    df_result = pd.DataFrame(results)

    return df_result

# Main application class
class FuzzyMatcherApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Fuzzy Matcher")
        self.geometry("1000x600")
        self.categorization_var = tk.StringVar(value="Single")

        # File upload process
        self.df = None
        while self.df is None:
            file_path = filedialog.askopenfilename(title= "Please select a file containing your dataset")
            if file_path:
                self.df = file_import(file_path)
            else:
                # User didn't select a file, you can choose to exit or continue prompting
                messagebox.showinfo("Info", "Please select a dataset to proceed.")
                continue

        # Preprocess text, initialize categories and label all responses as 'Uncategorized'
        self.initialize_data_structures()

        # Ask for categorization type after file is selected
        self.after(100, self.set_categorization_type)

        # Label for showing the categorization type
        self.categorization_label = tk.Label(self, text="")
        self.categorization_label.pack()

        # Match string input
        self.match_string_label = tk.Label(self, text="Enter String to Match:")
        self.match_string_label.pack()
        self.match_string_entry = tk.Entry(self)
        self.match_string_entry.pack()

        # Threshold score slider
        self.threshold_label = tk.Label(self, text="Set Fuzz Threshold (100 is precise, 0 is imprecise):")
        self.threshold_label.pack()
        self.threshold_slider = tk.Scale(self, from_=0, to=100, orient="horizontal", resolution=1,
                                        command=lambda val: self.display_match_results())
        self.threshold_slider.set(60)  # Setting default value to 60
        self.threshold_slider.pack()

        # Match button
        self.process_button = tk.Button(self, text="Match", command=self.process_match)
        self.process_button.pack()

        # Results display area
        self.results_tree = ttk.Treeview(self, columns=('Response', 'Max Score', 'Count'), show='headings')
        self.results_tree.heading('Response', text='Response')
        self.results_tree.heading('Max Score', text='Max Score')
        self.results_tree.heading('Count', text='Count')
        self.results_tree.pack(expand=True, fill='both')

        # Enter new category
        self.new_category_entry = tk.Entry(self)
        self.new_category_entry.pack()
        self.add_category_button = tk.Button(self, text="Add Category", command=self.create_category)
        self.add_category_button.pack()

        # Display categories
        self.categories_tree = ttk.Treeview(self, columns=('Category', 'Count'), show='headings')
        self.categories_tree.heading('Category', text='Category')
        self.categories_tree.heading('Count', text='Count')
        self.categories_tree.pack(expand=True, fill='both')
        self.display_categories()

        self.display_category_results_button = tk.Button(self, text="Display Category Results", command=self.display_category_results)
        self.display_category_results_button.pack()

        # Categorize selected results
        self.categorize_button = tk.Button(self, text="Categorize Selected", command=self.categorize_response)
        self.categorize_button.pack()

        # Export to CSV button
        self.export_csv_button = tk.Button(self, text="Export to CSV", command=self.export_to_csv)
        self.export_csv_button.pack()

    def initialize_data_structures(self):
        # Preprocess text
        self.df_preprocessed = self.df.iloc[:, 1:].map(preprocess_text)

        # Flatten the DataFrame to a Series of responses
        df_series = self.df_preprocessed.stack().reset_index(drop=True)
        df_unique = df_series.unique()

        # Count each response including duplicates
        self.response_counts = df_series.value_counts().to_dict()

        # Initialize categories and set all unique responses to 'Uncategorized'
        self.categories = {'Uncategorized': set(df_unique)}

        # Initialize match results dataframe
        self.match_results = pd.DataFrame(columns=['response', 'score'])

    def set_categorization_type(self):
        popup = tk.Toplevel(self)
        popup.title("Select Categorization Type")
        popup.geometry("400x200")

        # Center the popup on the main window
        window_width = self.winfo_reqwidth()
        window_height = self.winfo_reqheight()
        position_right = int(self.winfo_screenwidth()/2 - window_width/2)
        position_down = int(self.winfo_screenheight()/2 - window_height/2)
        popup.geometry("+{}+{}".format(position_right, position_down))

        # Keep the popup window on top
        popup.transient(self)  # Keep it on top of the main window
        popup.grab_set()       # Ensure all events are directed to this window until closed

        def confirm_categorization_type():
            chosen_type = self.categorization_var.get()
            self.categorization_label.config(text="Categorization Type: " + chosen_type)

        single_categorization_rb = tk.Radiobutton(popup, text="Single Categorization", variable=self.categorization_var, value="Single")
        multi_categorization_rb = tk.Radiobutton(popup, text="Multi Categorization", variable=self.categorization_var, value="Multi")
        confirm_button = tk.Button(popup, text="Confirm", command=lambda: [confirm_categorization_type(), popup.destroy()])

        single_categorization_rb.pack()
        multi_categorization_rb.pack()
        confirm_button.pack()

    def create_category(self):
        new_category = self.new_category_entry.get()
        if new_category and new_category not in self.categories:
            self.categories[new_category] = set()
            self.display_categories()

    def display_categories(self):
        selected_categories = self.selected_categories()

        for item in self.categories_tree.get_children():
            self.categories_tree.delete(item)
        
        for category, responses in self.categories.items():
            count = sum(self.response_counts.get(response, 0) for response in responses)
            self.categories_tree.insert('', 'end', values=(category, count))
            self.update_treeview_selection(selected_categories=selected_categories)

    def display_category_results(self):
        selected_categories = self.categories_tree.selection()
        
        if len(selected_categories) == 1:
            category = self.categories_tree.item(selected_categories[0])['values'][0]
            
            # Clear existing items in the results display area
            for item in self.results_tree.get_children():
                self.results_tree.delete(item)

            # Display responses and counts for the selected category
            if category in self.categories:
                for response in self.categories[category]:
                    count = self.response_counts[response]
                    self.results_tree.insert('', 'end', values=(response, count))

            # Update the results display to reflect the selected category
            self.match_string_label.config(text=f"Results for Category: {category}")

        elif len(selected_categories) > 1:
            messagebox.showerror("Error", "Please select only one category")
        
        else:
            messagebox.showerror("Error", "No category selected")

    def categorize_response(self):
        selected_responses = self.selected_responses()
        selected_categories = self.selected_categories()
        if not selected_categories or not selected_responses:
            messagebox.showinfo("Info", "Please select both a category and responses to categorize.")
            return

        if self.categorization_var.get() == "Single" and len(selected_categories) > 1:
            messagebox.showwarning("Warning", "Only one category can be selected in Single Categorization mode.")
            return

        for category in selected_categories:
            # Add response to categorized data
            self.categories[category].update(selected_responses)

            # Remove from 'Uncategorized' if single-categorization
            if self.categorization_var.get() == "Single":
                self.categories['Uncategorized'] -= selected_responses
                self.match_results = self.match_results[~self.match_results['response'].isin(self.selected_responses())]

        # Update categories and results displays
        self.display_categories()
        self.display_match_results()
        self.update_treeview_selection(selected_categories=selected_categories, selected_responses=selected_responses)

    def process_match(self):
        if self.df_preprocessed is not None:
            # Fuzzy match
            self.match_results = fuzzy_matching(self.df_preprocessed, self.match_string_entry)
            self.display_match_results()
        else:
            messagebox.showerror("Error", "No dataset loaded")
        
    def display_match_results(self):
        # Retrieve the current threshold value from the slider
        threshold = self.threshold_slider.get()

        # Filter the results based on the threshold
        filtered_results = self.match_results[self.match_results['score'] >= threshold]

        # Aggregate and count unique instances
        aggregated_results = filtered_results.groupby('response').agg(
            max_score=pd.NamedAgg(column='score', aggfunc='max'),
            count=pd.NamedAgg(column='response', aggfunc='count')
        ).reset_index()

        # Sort the results first by max_score in descending order, then by count in descending order
        sorted_results = aggregated_results.sort_values(by=['max_score', 'count'], ascending=[False, False])

        # Clear existing items in the results display area
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)

        # Populate the display area with aggregated unique filtered results
        for _, row in sorted_results.iterrows():
            self.results_tree.insert('', 'end', values=(row['response'], row['max_score'], row['count']))

        ### Update this method to display ORIGINAL STRING ###

    def selected_categories(self):
        return {self.categories_tree.item(item_id)['values'][0] for item_id in self.categories_tree.selection()}
    
    def selected_responses(self):
        return {self.results_tree.item(item_id)['values'][0] for item_id in self.results_tree.selection()}

    def update_treeview_selection(self, selected_categories=None, selected_responses=None):
        def reselect_treeview_items(treeview, values):
            for item in treeview.get_children():
                if treeview.item(item)['values'][0] in values:
                    treeview.selection_add(item)

        # Re-select categories and if multi-categorization re-select match results
        if selected_categories is not None:
            reselect_treeview_items(self.categories_tree, selected_categories)
        if self.categorization_var.get() == "Multi" and selected_responses is not None:
            reselect_treeview_items(self.results_tree, selected_responses)

    def save_session(self):
        # Logic to save current state in json (or other data type), to be reloaded later
        pass

    def load_session(self):
        # Logic to load previously saved state from json (or other data type)
        pass

    def export_to_csv(self):
        # Convert categorized data to DataFrame
        categorized_df = pd.DataFrame(list(self.categories.items()), columns=['Category', 'Responses'])

        # Flatten the 'Responses' column
        categorized_df = categorized_df.explode('Responses')

        # Ask the user where to save the file
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save As"
        )

        # Check if the user has selected a file path
        if file_path:
            # Export to CSV
            categorized_df.to_csv(file_path, index=False)
            messagebox.showinfo("Export", "Data exported successfully to " + file_path)
        else:
            messagebox.showinfo("Export", "Export cancelled")

        ### Update this to ensure the correct format (uuids + categories with binary values) ###

# Running the application
if __name__ == "__main__":
    app = FuzzyMatcherApp()
    app.mainloop()